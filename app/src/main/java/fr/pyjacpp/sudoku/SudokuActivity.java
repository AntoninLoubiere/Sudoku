package fr.pyjacpp.sudoku;import android.annotation.SuppressLint;import android.app.Dialog;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.graphics.Point;import android.os.Bundle;import android.support.constraint.ConstraintLayout;import android.support.design.widget.CoordinatorLayout;import android.support.v7.app.AlertDialog;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.view.animation.AnimationUtils;import android.widget.Button;import android.widget.GridLayout;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.PopupWindow;import android.widget.RadioButton;import android.widget.TextView;import android.widget.Toast;import java.util.ArrayList;import java.util.Random;import java.util.Stack;public class SudokuActivity extends AppCompatActivity {    private TileView numberClick_currentNumber = null;    private int[] numberClick_currentNumberCoord = new int[2];    private PopupWindow popup = new PopupWindow();    private GridLayout[] listGridLayout = new GridLayout[9];    GridLayout mainGrid;    private int[][] sudokuGrid = new int[9][9];    private TileView[][] listTileViews = new TileView[9][9];    private TextView informationTextView;    private ImageView undoImageView;    private ImageView redoImageView;    private boolean[][] toFindTiles = new boolean[9][9];    private int numberTileToRemove = 40;    private int numberTileremaining = 0;    private boolean showConflict = true;    private boolean gameFinish = false;    private boolean hintMode = false;    private int[] hintSelectNumber = new int[2];    private int widhtToResize;    private Stack<NumberChange> undoList = new Stack<>();    private Stack<NumberChange> redoList = new Stack<>();    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        numberTileToRemove = getIntent().getIntExtra("numberTilesToRemove",                40);        showConflict = getIntent().getBooleanExtra("showConflictSwitch",                showConflict);        setContentView(R.layout.activity_sudoku);        mainGrid = findViewById(R.id.sudoku_mainLayout);        informationTextView = findViewById(R.id.textViewInforamtion);        undoImageView = findViewById(R.id.buttonActionUndo);        redoImageView = findViewById(R.id.buttonActionRedo);        Button newGameButton = findViewById(R.id.newGameButton);        Button mainMenuButton = findViewById(R.id.mainMenuButton);        newGameButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                newGame();            }        });        mainMenuButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                finish();            }        });        // resize widgets        Point size = new Point();        getWindowManager().getDefaultDisplay().getSize(size);        widhtToResize = size.x;        newGameButton.setTextSize(widhtToResize * 0.0291666f);        mainMenuButton.setTextSize(widhtToResize * 0.0291666f);        configureActionButtons();        // create grid        Log.i("SudokuActivity", "Start to created the grid");        initGrid();        createGrid();        removeSomeTiles();        popup_Create();        createGridGraphics();        Log.i("SudokuActivity", "The grid and graphics were created");    }    private void configureActionButtons() {        LinearLayout barButtonLayout = findViewById(R.id.barButtonActions);        ((ConstraintLayout.LayoutParams) barButtonLayout.getLayoutParams()).setMargins(0, 8,                0, (int) (widhtToResize * 0.0625f) + 8); // same than size textview        ImageView abort = findViewById(R.id.buttonActionAbort);        ImageView hint = findViewById(R.id.buttonActionHint);        ImageView restart = findViewById(R.id.buttonActionRestart);        ImageView mainMenu = findViewById(R.id.buttonActionMainMenu);        abort.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(final View v) {                abortButtonOnClick();            }        });        hint.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                hintButtonClick();            }        });        restart.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                restartButtonOnClick();            }        });        mainMenu.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                mainMenuButtonClick();            }        });        undoImageView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                undoMenuButtonClick();            }        });        redoImageView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                redoMenuButtonClick();            }        });                // long click        abort.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                         Toast.LENGTH_SHORT).show();                return true;            }        });        hint.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        undoImageView.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        redoImageView.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        restart.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        mainMenu.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });            }    private void abortButtonOnClick() {        if (!gameFinish) {            new AlertDialog.Builder(this)                    .setTitle(R.string.dialog_abort_title)                    .setMessage(R.string.dialog_abort_message)                    .setPositiveButton(R.string.dialog_abort, new                            DialogInterface.OnClickListener() {                                @Override                                public void onClick(DialogInterface dialog, int which) {                                    stopGame(false);                                }                            })                    .setNegativeButton(R.string.dialog_cancel, null)                    .show();        }    }    private void hintButtonClick() {        if (!gameFinish) {            if (hintMode) {                // remove hint mode                setHintMode(false);            } else {                // selecte tile to hint                setHintMode(true);            }        }    }    private void restartButtonOnClick() {        if (gameFinish) {            newGame();        } else {            final Dialog dialog = new Dialog(this);            dialog.setTitle(R.string.dialog_restart_title);            dialog.setContentView(R.layout.dialog_restart_game);            final RadioButton restartThisGameButton = dialog.findViewById(R.id.restartThisGameButton);            final RadioButton restartNewGameButton = dialog.findViewById(R.id.restartNewGameButton);            dialog.findViewById(R.id.validButton).setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    if (restartThisGameButton.isChecked()) {                        reinitSudokuGrid();                    } else if (restartNewGameButton.isChecked()) {                        newGame();                    }                    dialog.dismiss();                }            });            dialog.findViewById(R.id.cancelButton).setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    dialog.dismiss();                }            });            dialog.show();        }    }    private void mainMenuButtonClick() {        if (gameFinish) {            finish();        } else {            new AlertDialog.Builder(this)                    .setTitle(R.string.dialog_main_menu_title)                    .setMessage(R.string.dialog_main_menu_message)                    .setNegativeButton(R.string.dialog_main_menu_no, null)                    .setPositiveButton(R.string.dialog_main_menu_yes, new                            DialogInterface.OnClickListener() {                                @Override                                public void onClick(DialogInterface dialog, int which) {                                    finish();                                }                            })                    .show();        }    }    private void undoMenuButtonClick() {        if (undoList.size() > 0) {            final NumberChange currentNumberChange = undoList.lastElement();            if (listTileViews                    [currentNumberChange.getX()]                    [currentNumberChange.getY()].                    isUserModifiable()) {                addRedo(listTileViews                                [currentNumberChange.getX()]                                [currentNumberChange.getY()].                                getNumber(),                        currentNumberChange.getX(),                        currentNumberChange.getY());                // do undo                listTileViews[currentNumberChange.getX()][currentNumberChange.getY()].                        setNumber(currentNumberChange.getNumber());                // remove / add conflicts                new Thread(new Runnable() {                    @Override                    public void run() {                        testConflict(currentNumberChange.getX(), currentNumberChange.getY());                    }                }).run();            }            removeUndo(currentNumberChange);        }    }    private void redoMenuButtonClick() {        if (redoList.size() > 0) {            final NumberChange currentNumberChange = redoList.lastElement();            if (listTileViews                    [currentNumberChange.getX()]                    [currentNumberChange.getY()].                    isUserModifiable()) {                addUndo(listTileViews                                [currentNumberChange.getX()]                                [currentNumberChange.getY()].                                getNumber(),                        currentNumberChange.getX(),                        currentNumberChange.getY());                // do redo                listTileViews[currentNumberChange.getX()][currentNumberChange.getY()].                        setNumber(currentNumberChange.getNumber());                new Thread(new Runnable() {                    @Override                    public void run() {                        testConflict(currentNumberChange.getX(), currentNumberChange.getY());                    }                }).run();            }            removeRedo(currentNumberChange);        }    }    private void newGame() {        Intent intent = new Intent(getApplicationContext(),                ConfigureSudokuGridActivity.class);        intent.putExtra("numberTilesToRemove", numberTileToRemove);        intent.putExtra("showConflictSwitch", showConflict);        startActivity(intent);        finish();    }    private void popup_Create() {        LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);        assert inflater != null;        @SuppressLint("InflateParams")        View customView = inflater.inflate(R.layout.layout_popup, null);        popup = new PopupWindow(customView,                CoordinatorLayout.LayoutParams.WRAP_CONTENT,                CoordinatorLayout.LayoutParams.WRAP_CONTENT);        popup.setOutsideTouchable(true);        popup.setFocusable(true);        popup.setBackgroundDrawable(getResources().getDrawable(R.drawable.popup_border));        popup.setOnDismissListener(new PopupWindow.OnDismissListener() {            @Override            public void onDismiss() {                if (numberClick_currentNumber != null)                    numberClick_currentNumber.setSelected(false);            }        });        final Button[] popupButton = new Button[12];        popupButton[0] = popup.getContentView().findViewById(R.id.Button1);        popupButton[1] = popup.getContentView().findViewById(R.id.Button2);        popupButton[2] = popup.getContentView().findViewById(R.id.Button3);        popupButton[3] = popup.getContentView().findViewById(R.id.Button4);        popupButton[4] = popup.getContentView().findViewById(R.id.Button5);        popupButton[5] = popup.getContentView().findViewById(R.id.Button6);        popupButton[6] = popup.getContentView().findViewById(R.id.Button7);        popupButton[7] = popup.getContentView().findViewById(R.id.Button8);        popupButton[8] = popup.getContentView().findViewById(R.id.Button9);        popupButton[9] = popup.getContentView().findViewById(R.id.ButtonSquare);        popupButton[10] = popup.getContentView().findViewById(R.id.ButtonNothing);        popupButton[11] = popup.getContentView().findViewById(R.id.ButtonCircle);        for (int i = 0; i < popupButton.length; i ++) {            final int finalI = i;            popupButton[i].setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    onButtonPopupClick(finalI);                }            });            popupButton[i].getLayoutParams().width = (int) (widhtToResize * 0.15625f);            popupButton[i].getLayoutParams().height = (int) (widhtToResize * 0.15625f);            popupButton[i].setTextSize((widhtToResize * 0.15625f) * 0.5f);        }    }            private void onButtonPopupClick(int buttonId) {        if (numberClick_currentNumber != null) {            if (numberClick_currentNumber.getNumber() <= 9 && buttonId + 1 > 9) {                // if previous number is a number and the next not a number:                numberTileremaining++;            } else if (buttonId + 1 <= 9 && numberClick_currentNumber.getNumber() > 9) {                // if next number is a number and the previous not a number:                numberTileremaining--;            }            clearRedoList(); // because the undo list change            if (numberClick_currentNumber.getNumber() != buttonId + 1)// don't add if it is the same                addUndo(numberClick_currentNumber.getNumber(), numberClick_currentNumberCoord[0],                        numberClick_currentNumberCoord[1]);            numberClick_currentNumber.setNumber(buttonId + 1);            updateWinAndConflict();            popup.dismiss();        }    }    private void updateWinAndConflict() {        if (showConflict) {            new Thread(new Runnable() {                @Override                public void run() {                    testWin();                    testConflict(numberClick_currentNumberCoord[0],                            numberClick_currentNumberCoord[1]);                }            }).run();        } else {            new Thread(new Runnable() {                @Override                public void run() {                    testWin();                }            }).run();        }    }    private void testWin() {        if (numberTileremaining <= 0) {            if (verifyGrid()) {                stopGame(true);            }        }    }    private void reinitSudokuGrid() {        mainGrid.removeAllViews();        clearRedoList();        clearUndoList();        createGridGraphics();    }    private void initGrid() {        for (int x = 0; x < 3; x++) {            for (int y = 0; y < 3; y++) {                sudokuGrid[x][y] = 0;            }        }    }    private void createGrid() {        SudokuGridGenerator sudokuGridGenerator = new SudokuGridGenerator();        int[] sudokuGridCreated;        do {            sudokuGridCreated = sudokuGridGenerator.generateGrid();        } while (!SudokuGridGenerator.isPerfect(sudokuGridCreated));        // SudokuGridGenerator.printGrid(sudokuGridCreated);        // convert grid        for (int i = 0; i < 81; i++) {            sudokuGrid[i / 9][i % 9] = sudokuGridCreated[i];        }    }    private void createGridGraphics() {        int number_size = (widhtToResize - 50) / 9;        mainGrid.setColumnCount(3);        mainGrid.setRowCount(3);        for (int gridLayout = 0; gridLayout < 9; gridLayout++) {            listGridLayout[gridLayout] = new GridLayout(this);            listGridLayout[gridLayout].setBackgroundResource(R.drawable.large_border);            listGridLayout[gridLayout].setPadding(2, 2, 2, 2);            listGridLayout[gridLayout].setRowCount(3);            listGridLayout[gridLayout].setColumnCount(3);            mainGrid.addView(listGridLayout[gridLayout]);            for (int i = 0; i < 9; i++) {                final int x = i % 3  + gridLayout % 3 * 3;                final int y = i / 3 + gridLayout / 3 * 3;                listTileViews[x][y] = new TileView(this);                listTileViews[x][y].setUserModifiable(toFindTiles[x][y]);                listTileViews[x][y].setSizeFont(number_size * 0.9f);                if (toFindTiles[x][y]) {                    listTileViews[x][y].setNumber(11);                    listTileViews[x][y].setOnClickListener(new View.OnClickListener() {                        @Override                        public void onClick(View v) {                            onNumberClick((TileView) v, x, y);                        }                    });                    listTileViews[x][y].setNumberFontColor(                            getResources().getColor(R.color.user_number_color));                } else {                    listTileViews[x][y].setNumber(sudokuGrid[x][y]);                }                CoordinatorLayout.LayoutParams params = new                        CoordinatorLayout.LayoutParams(number_size, number_size);                listTileViews[x][y].setLayoutParams(params);                listGridLayout[gridLayout].addView(listTileViews[x][y]);            }        }    }    private void onNumberClick(TileView tileView, int x, int y) {        if (numberClick_currentNumber != null)            numberClick_currentNumber.setSelected(false);        numberClick_currentNumber = tileView;        numberClick_currentNumber.setSelected(true);        numberClick_currentNumberCoord[0] = x;        numberClick_currentNumberCoord[1] = y;        if (hintMode) {            if (hintSelectNumber[0] == x && hintSelectNumber[1] == y) {                // if is the same number / he click twice on it                setHintMode(false);                // give hint                if (!(0 < tileView.getNumber() && tileView.getNumber() <= 9))                    numberTileremaining--;                tileView.setUserModifiable(false);                tileView.setOnClickListener(null); // remove click                tileView.setNumber(sudokuGrid[x][y]);                tileView.setNumberFontColor(getResources().getColor(R.color.text_hint));                updateWinAndConflict();            } else {                hintSelectNumber[0] = x;                hintSelectNumber[1] = y;                informationTextView.setText(R.string.hint_new_click_ask);            }        } else {            popup.showAtLocation(mainGrid, Gravity.CENTER, 0, 0);        }    }    private void removeSomeTiles() {        Random random = new Random();        int numberDisable = 0;        while (numberDisable < numberTileToRemove / 2) {            int x = random.nextInt(9);            int y = random.nextInt(9);            if (!toFindTiles[x][y]) {                int reverseX = x * -1 + 8;                int reverseY = y *-1 + 8;                toFindTiles[x][y] = true;                toFindTiles[reverseX][reverseY] = true;                if (x == reverseX && reverseY == y) // same tile                    numberTileremaining += 1;                else                    numberTileremaining += 2;                numberDisable++;            }        }    }    private boolean verifyGrid() {        // test lines        for (int y = 0; y < 9; y++) {            // reset            boolean[] numberExist = {                    false, false, false,                    false, false, false,                    false, false, false};            for (int x = 0; x < 9; x++) {                if (listTileViews[x][y].getNumber() > 9) { // not number                    Log.w("SudokuActivity", "Warning, the tile isn't a number ! (" +                            numberTileremaining + " is / are remaining)");                    return false;                }                if (!numberExist[listTileViews[x][y].getNumber() - 1]) {                    numberExist[listTileViews[x][y].getNumber() - 1] = true;                } else {                    return false;                }            }        }        // reset        // test column        for (int x = 0; x < 9; x++) {            // reset            boolean[] numberExist = {                    false, false, false,                    false, false, false,                    false, false, false};            for (int y = 0; y < 9; y++) {                if (listTileViews[x][y].getNumber() > 9) { // not number                    Log.w("SudokuActivity", "Warning, the tile isn't a number ! (" +                            numberTileremaining + " is / are remaining)");                    return false;                }                if (!numberExist[listTileViews[x][y].getNumber() - 1]) {                    numberExist[listTileViews[x][y].getNumber() - 1] = true;                } else {                    return false;                }            }        }        // test sqaure        for (int sqaure = 0; sqaure < 9; sqaure++) {            // reset            boolean[] numberExist = {                    false, false, false,                    false, false, false,                    false, false, false};            for (int x = sqaure % 3 * 3; x < sqaure % 3 * 3 + 3; x++) {                for (int y = sqaure / 3 * 3; y < sqaure / 3 * 3; y++) {                    if (listTileViews[x][y].getNumber() > 9) { // not number                        Log.w("SudokuActivity", "Warning, the tile isn't a number ! (" +                                numberTileremaining + " is / are remaining)");                        return false;                    }                    if (!numberExist[listTileViews[x][y].getNumber() - 1]) {                        numberExist[listTileViews[x][y].getNumber() - 1] = true;                    } else {                        return false;                    }                }            }        }        return true;    }    private void testConflict(int tileX, int tileY) {        ArrayList<int[]> toVerify = new ArrayList<>(); // format: 0: type, 1: x, 2: y        // test lines        boolean inConflict = false;        for (int x = 0; x < 9; x++) {            // test if not the same number            if (x != tileX) {                if (listTileViews[x][tileY].getNumber() != 11 &&                        listTileViews[x][tileY].getNumber() == listTileViews[tileX][tileY].getNumber()) {                    // same value:                    listTileViews[x][tileY].setConflict(0, true);                    inConflict = true;                } else if (listTileViews[x][tileY].getInConflict(0)) {                    int[] conflict = new int[3];                    /* conflict[0] = 0; aleraedy set */ conflict[1] = x; conflict[2] = tileY;                    toVerify.add(conflict);                }            }        }        listTileViews[tileX][tileY].setConflict(0, inConflict);        // test column        inConflict = false;        for (int y = 0; y < 9; y++) {            // test if not the same number            if (y != tileY) {                if (listTileViews[tileX][y] .getNumber() != 11 &&                        listTileViews[tileX][y] .getNumber() == listTileViews[tileX][tileY]                        .getNumber()) {                    // same value:                    listTileViews[tileX][y].setConflict(1, true);                    inConflict = true;                } else if (listTileViews[tileX][y].getInConflict(1)) {                    int[] conflict = new int[3];                    conflict[0] = 1; conflict[1] = tileX; conflict[2] = y;                    toVerify.add(conflict);                }            }        }        listTileViews[tileX][tileY].setConflict(1, inConflict);        // test square        inConflict = false;        for (int x = tileX / 3 * 3; x < tileX / 3 * 3 + 3; x++) { // loop on sqaure            for (int y = tileY / 3 *3; y < tileY / 3 *3 + 3; y++) {                // test if not the same number                if (x != tileX && y != tileY) {                    if (listTileViews[x][y].getNumber() != 11 &&                            listTileViews[x][y].getNumber() == listTileViews[tileX][tileY]                            .getNumber()) {                        // same value:                        listTileViews[x][y].setConflict(2, true);                        inConflict = true;                    } else if (listTileViews[x][y].getInConflict(2)) {                        int[] conflict = new int[3];                        conflict[0] = 2; conflict[1] = x; conflict[2] = y;                        toVerify.add(conflict);                    }                }            }        }        listTileViews[tileX][tileY].setConflict(2, inConflict);        // verify numbers        for (int[] conflict : toVerify) {            // conflict format: 0: type, 1: x, 2: y            boolean isInConflict = false;            if (conflict[0] == 0) {                // test line                for (int x = 0; x < 9; x++) {                    if (x != conflict[1]) {                        if (listTileViews[conflict[1]][conflict[2]].getNumber() ==                                listTileViews[x][conflict[2]].getNumber()) {                            isInConflict = true;                        }                    }                }            } else if (conflict[0] == 1) {                // test column                for (int y = 0; y < 9; y++) {                    if (y != conflict[2]) {                        if (listTileViews[conflict[1]][conflict[2]].getNumber() ==                                listTileViews[conflict[1]][y].getNumber()) {                            isInConflict = true;                        }                    }                }            } else if (conflict[0] == 2) {                // test sqaure                for (int x = tileX / 3 * 3; x < tileX / 3 * 3 + 3; x++) {                    for (int y = tileY / 3 *3; y < tileY / 3 *3 + 3; y++) {                        if (x != conflict[1] && y != conflict[2]) {                            if (listTileViews[conflict[1]][conflict[2]].getNumber() ==                                    listTileViews[conflict[1]][y].getNumber()) {                                isInConflict = true;                            }                        }                    }                }            }            if (!isInConflict) {                listTileViews[conflict[1]][conflict[2]].setConflict(conflict[0], false);            }        }    }    private void stopGame(boolean win) {        if (hintMode)            setHintMode(false);        gameFinish = true;        LinearLayout buttonsEndGameBar = findViewById(R.id.buttonsEndGameBar);        buttonsEndGameBar.setVisibility(View.VISIBLE);        buttonsEndGameBar.startAnimation(AnimationUtils.loadAnimation(this,                R.anim.end_buttons_animation));        disableClickListeners();        informationTextView.setTextSize(widhtToResize * 0.0625f);        findViewById(R.id.buttonActionAbort).setVisibility(View.GONE);        findViewById(R.id.buttonActionHint).setVisibility(View.GONE);        findViewById(R.id.buttonActionUndo).setVisibility(View.GONE);        findViewById(R.id.buttonActionRedo).setVisibility(View.GONE);        if (win && testUserDoGrid()) {            // win            informationTextView.setText(R.string.game_result_win);            informationTextView.setTextColor(getResources().getColor(R.color.text_win));            for (int x = 0; x < 9; x++) {                for (int y = 0; y < 9; y++) {                    if (listTileViews[x][y].isUserModifiable()) {                        listTileViews[x][y].setNumberFontColor(getResources().getColor(                                R.color.text_win));                    }                }            }        } else {            // lose            informationTextView.setText(R.string.game_result_abort);            informationTextView.setTextColor(getResources().getColor(R.color.text_lose));            for (int x = 0; x < 9; x++) {                for (int y = 0; y < 9; y++) {                    listTileViews[x][y].setConflict(0, false); // force to remove                    listTileViews[x][y].setConflict(1, false); // conflict (remove the                    listTileViews[x][y].setConflict(2, false); // color)                    if (listTileViews[x][y].isUserModifiable()) {                        if (listTileViews[x][y].getNumber() == sudokuGrid[x][y]) {                            listTileViews[x][y].setNumberFontColor(getResources().getColor(                                    R.color.text_win));                        } else {                            listTileViews[x][y].setNumberFontColor(getResources().getColor(                                    R.color.text_lose));                            listTileViews[x][y].setNumber(sudokuGrid[x][y]);                        }                    }                }            }        }        informationTextView.startAnimation(AnimationUtils.loadAnimation(this,                R.anim.end_text_animation));    }    private boolean testUserDoGrid() {        // verify if the user don't use only hint        for (int x = 0; x < 9; x++) {            for (int y = 0; y < 9; y++) {                if (listTileViews[x][y].isUserModifiable()) { // if the user do that                    return true;                }            }        }        return false;    }    private void disableClickListeners() {        for (int x = 0; x < 9; x++) {            for (int y = 0; y < 9; y++) {                listTileViews[x][y].setOnClickListener(null);            }        }    }    private void setHintMode(boolean hintMode) {        this.hintMode = hintMode;        if (hintMode) {            informationTextView.setText(R.string.hint_mode_text);            informationTextView.setTextSize(widhtToResize * 0.041666667f);            informationTextView.setTextColor(getResources().getColor(R.color.text_hint));            informationTextView.startAnimation(AnimationUtils.loadAnimation(this,                    R.anim.hint_text_animation));            hintSelectNumber[0] = -1;            hintSelectNumber[1] = -1;        } else {            informationTextView.setText("");            if (numberClick_currentNumber != null)                numberClick_currentNumber.setSelected(false);        }    }    private void addUndo(int number, int x, int y) {        undoList.add(new NumberChange(x, y, number));        if (undoList.size() > 100) {            undoList.remove(0);        }        else if (undoList.size() == 1)            undoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_undo));    }    private void removeUndo(NumberChange numberChange) {        undoList.remove(numberChange);        if (undoList.empty())            undoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_undo_disable));    }    private void clearUndoList() {        if (!undoList.empty()) {            undoList.clear();            undoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_undo_disable));        }    }    private void addRedo(int number, int x, int y) {        redoList.add(new NumberChange(x, y, number));        if (redoList.size() > 100) {            redoList.remove(0);        }        else if (redoList.size() == 1)            redoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_redo));    }    private void removeRedo(NumberChange numberChange) {        redoList.remove(numberChange);        if (redoList.empty())            redoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_redo_disable));    }    private void clearRedoList() {        if (!redoList.empty()) {            redoList.clear();            redoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_redo_disable));        }    }}