package fr.pyjacpp.sudoku;import android.annotation.SuppressLint;import android.app.Dialog;import android.content.ClipData;import android.content.ClipboardManager;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.graphics.Color;import android.graphics.Point;import android.os.Bundle;import android.os.Handler;import android.support.design.widget.CoordinatorLayout;import android.support.v7.app.AlertDialog;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.view.animation.AnimationUtils;import android.widget.Button;import android.widget.GridLayout;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.PopupWindow;import android.widget.RadioButton;import android.widget.TextView;import android.widget.Toast;import java.text.NumberFormat;import java.util.ArrayList;import fr.pyjacpp.sudoku.undochange.ColorUndoChange;import fr.pyjacpp.sudoku.undochange.NumberUndoChange;import fr.pyjacpp.sudoku.undochange.SwapColorUndoChange;import fr.pyjacpp.sudoku.undochange.UndoChange;public class SudokuActivity extends AppCompatActivity {    private final static int DELAY_AUTO_SAVE = 60 * 1000;    private final static int MAX_UNDO = 200;    private GridLayout mainGrid;    private TileView numberClick_currentNumber = null;    private int[] numberClick_currentNumberCoordinate = new int[2];    private PopupWindow popup = new PopupWindow();    private GridLayout[] listGridLayout = new GridLayout[9];    private TileView[][] listTileViews = new TileView[9][9];    private TextView informationTextView;    private TextView endGameTextView;    private ImageView undoImageView;    private ImageView redoImageView;    private boolean showConflict = true;    private boolean hintMode = false;    private int[] hintSelectNumber = new int[2];    private boolean swapMode = false;    private int selectedColorToSwap = -1;    private int[] selectedNumberSwap = new int[]{-1, -1};    private int widthToResize;    private Handler autoSaveHandler = new Handler();    private Runnable autoSaveRunnable = new Runnable() {        @Override        public void run() {            if (getSudokuGrid() != null) {                Log.i("SudokuActivity", "Auto save: Save the grid");                ((SudokuApplication) getApplicationContext()).saveGrid();                getSudokuGrid().reCalculateNumberNumberRemaining();                testWin();                if (!getSudokuGrid().isGameFinish())                    autoSaveHandler.postDelayed(autoSaveRunnable, DELAY_AUTO_SAVE);            }        }    };    private final static int[] listColorChoose = {            Color.parseColor("#debaba"),            Color.parseColor("#ded5ba"),            Color.parseColor("#ccdeba"),            Color.parseColor("#badec3"),            Color.parseColor("#badede"),            Color.parseColor("#bac3de"),            Color.parseColor("#ccbade"),            Color.parseColor("#debad5"),            Color.parseColor("#ffffff"),    };    private final static int[] listColorChooseButtonColor = {            Color.parseColor("#c58787"),            Color.parseColor("#c5b587"),            Color.parseColor("#a6c587"),            Color.parseColor("#87c596"),            Color.parseColor("#87c5c5"),            Color.parseColor("#8796c5"),            Color.parseColor("#a687c5"),            Color.parseColor("#c587b5"),            Color.parseColor("#C4C4C4"),    };    private Button[] colorChooseButtonList = new Button[listColorChoose.length];    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        int numberTileToRemove = getIntent().getIntExtra("numberTilesToRemove",                40);        showConflict = getIntent().getBooleanExtra("showConflictSwitch",                showConflict);        setContentView(R.layout.activity_sudoku);        mainGrid = findViewById(R.id.sudoku_mainLayout);        informationTextView = findViewById(R.id.informationTextView);        endGameTextView = findViewById(R.id.endGameTextView);        undoImageView = findViewById(R.id.buttonActionUndo);        redoImageView = findViewById(R.id.buttonActionRedo);        findViewById(R.id.newGameButton).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                newGame();            }        });        findViewById(R.id.mainMenuButton).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                finish();            }        });        // resize widgets        Point size = new Point();        getWindowManager().getDefaultDisplay().getSize(size);        widthToResize = size.x;        configureActionButtons();        // create grid        Log.i("SudokuActivity", "Start to created the grid");        if (getSudokuGrid() == null) {            if (!((SudokuApplication) getApplicationContext()).preferencesIsLoad()) {                finish();                return;            } else {                long seed = getIntent().getLongExtra("seed", SudokuGrid.generateRandomSeed());                setSudokuGrid(new SudokuGrid(numberTileToRemove, seed));            }        }        // show seed        TextView seedTextView = findViewById(R.id.seedTextView);        seedTextView.setText(String.format(getResources().getString(R.string.seed_text), getGridId()));        seedTextView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                ClipboardManager clipboardManager = (ClipboardManager)                        getSystemService(CLIPBOARD_SERVICE);                ClipData data = ClipData.newPlainText("gridId", getGridId());                clipboardManager.setPrimaryClip(data);                Toast.makeText(SudokuActivity.this, getString(R.string.id_grid_copy),                        Toast.LENGTH_LONG).show();            }        });        popup_Create();        createChooseColorButton();        createGridGraphics();        if (getSudokuGrid().isGameFinish()) {            stopGame(getSudokuGrid().isGameWin(), true);        }        Log.i("SudokuActivity", "The grid and graphics were created");    }    @Override    public void onBackPressed() {        mainMenuButtonClick();    }    @Override    protected void onStart() {        // start auto save        if (!getSudokuGrid().isGameFinish()) {            Log.i("SudokuActivity", "Auto save: started");            autoSaveHandler.postDelayed(autoSaveRunnable, DELAY_AUTO_SAVE);        }        super.onStart();    }    @Override    protected void onStop() {        Log.i("SudokuActivity", "Auto save: stopped");        autoSaveHandler.removeCallbacks(autoSaveRunnable);        ((SudokuApplication) getApplicationContext()).saveGrid();        super.onStop();    }    private void configureActionButtons() {        ImageView abort = findViewById(R.id.buttonActionAbort);        // ImageView verifyGrid = findViewById(R.id.buttonActionVerifyGrid);        ImageView hint = findViewById(R.id.buttonActionHint);        ImageView swapColor = findViewById(R.id.buttonActionSwapColor);        ImageView restart = findViewById(R.id.buttonActionRestart);        ImageView mainMenu = findViewById(R.id.buttonActionMainMenu);        abort.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(final View v) {                abortButtonOnClick();            }        });        /*verifyGrid.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                verifyGridButtonOnClick();            }        });*/        hint.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                hintButtonClick();            }        });        swapColor.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                swapColorButtonClick();            }        });        restart.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                restartButtonOnClick();            }        });        mainMenu.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                mainMenuButtonClick();            }        });        undoImageView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                undoMenuButtonClick();            }        });        redoImageView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                redoMenuButtonClick();            }        });        // long click        abort.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });/*        verifyGrid.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });*/        hint.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        swapColor.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        undoImageView.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        redoImageView.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        restart.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        mainMenu.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });    }    private void abortButtonOnClick() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        if (!getSudokuGrid().isGameFinish()) {            new AlertDialog.Builder(this)                    .setTitle(R.string.dialog_abort_title)                    .setMessage(R.string.dialog_abort_message)                    .setPositiveButton(R.string.dialog_abort, new                            DialogInterface.OnClickListener() {                                @Override                                public void onClick(DialogInterface dialog, int which) {                                    stopGame(false);                                }                            })                    .setNegativeButton(R.string.dialog_cancel, null)                    .show();        }    }    /*private void verifyGridButtonOnClick() {        if (getSudokuGrid().verifyGrid()) {            stopGame(true);        }        else {            getSudokuGrid().reCalculateNumberNumberRemaining();        }    }*/    private void hintButtonClick() {        if (swapMode)            setSwapMode(false);        if (!getSudokuGrid().isGameFinish()) {            setHintMode(!hintMode);        }    }    private void swapColorButtonClick() {        if (hintMode)            setHintMode(false);        if (!getSudokuGrid().isGameFinish())            setSwapMode(!swapMode);    }    private void restartButtonOnClick() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        if (getSudokuGrid().isGameFinish()) {            newGame();        } else {            final Dialog dialog = new Dialog(this);            dialog.setTitle(R.string.dialog_restart_title);            dialog.setCanceledOnTouchOutside(true);            dialog.setContentView(R.layout.dialog_restart_game);            final RadioButton restartThisGameButton = dialog.findViewById(R.id.restartThisGameButton);            final RadioButton restartNewGameButton = dialog.findViewById(R.id.restartNewGameButton);            dialog.findViewById(R.id.validButton).setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    if (restartThisGameButton.isChecked()) {                        resetSudokuGrid();                    } else if (restartNewGameButton.isChecked()) {                        newGame();                    }                    dialog.dismiss();                }            });            dialog.findViewById(R.id.cancelButton).setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    dialog.dismiss();                }            });            dialog.show();        }    }    private void mainMenuButtonClick() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        if (getSudokuGrid().isGameFinish()) {            finish();        } else {            new AlertDialog.Builder(this)                    .setTitle(R.string.dialog_main_menu_title)                    .setMessage(R.string.dialog_main_menu_message)                    .setNegativeButton(R.string.dialog_main_menu_no, null)                    .setPositiveButton(R.string.dialog_main_menu_yes, new                            DialogInterface.OnClickListener() {                                @Override                                public void onClick(DialogInterface dialog, int which) {                                    finish();                                }                            })                    .show();        }    }    private void undoMenuButtonClick() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        if (getSudokuGrid().getUndoList().size() > 0) {            final UndoChange currentUndo = getSudokuGrid().getUndoList().lastElement();            UndoChange redoChange = currentUndo.doUndo(getSudokuGrid(), this);            if (redoChange != null) {                addRedo(redoChange);            }            removeUndo(currentUndo);        }    }    private void redoMenuButtonClick() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        if (getSudokuGrid().getRedoList().size() > 0) {            final UndoChange currentRedo = getSudokuGrid().getRedoList().lastElement();            UndoChange undoChange = currentRedo.doUndo(getSudokuGrid(), this);            if (undoChange != null) {                addUndo(undoChange);            }            removeRedo(currentRedo);        }    }    private void newGame() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        Intent intent = new Intent(getApplicationContext(),                ConfigureSudokuGridActivity.class);        intent.putExtra("numberTilesToRemove", getSudokuGrid().getNumberTileToRemove());        intent.putExtra("showConflictSwitch", showConflict);        startActivity(intent);        finish();    }    private void popup_Create() {        LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);        assert inflater != null;        @SuppressLint("InflateParams")        View customView = inflater.inflate(R.layout.layout_popup, null);        popup = new PopupWindow(customView,                CoordinatorLayout.LayoutParams.WRAP_CONTENT,                CoordinatorLayout.LayoutParams.WRAP_CONTENT);        popup.setOutsideTouchable(true);        popup.setFocusable(true);        popup.setBackgroundDrawable(getResources().getDrawable(R.drawable.popup_border));        popup.setOnDismissListener(new PopupWindow.OnDismissListener() {            @Override            public void onDismiss() {                if (numberClick_currentNumber != null)                    numberClick_currentNumber.setSelected(false);            }        });        final Button[] popupButton = new Button[12];        popupButton[0] = popup.getContentView().findViewById(R.id.ButtonNothing);        popupButton[1] = popup.getContentView().findViewById(R.id.Button1);        popupButton[2] = popup.getContentView().findViewById(R.id.Button2);        popupButton[3] = popup.getContentView().findViewById(R.id.Button3);        popupButton[4] = popup.getContentView().findViewById(R.id.Button4);        popupButton[5] = popup.getContentView().findViewById(R.id.Button5);        popupButton[6] = popup.getContentView().findViewById(R.id.Button6);        popupButton[7] = popup.getContentView().findViewById(R.id.Button7);        popupButton[8] = popup.getContentView().findViewById(R.id.Button8);        popupButton[9] = popup.getContentView().findViewById(R.id.Button9);        popupButton[10] = popup.getContentView().findViewById(R.id.ButtonSquare);        popupButton[11] = popup.getContentView().findViewById(R.id.ButtonCircle);        for (int i = 0; i < popupButton.length; i++) {            final int finalI = i;            popupButton[i].setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    onButtonPopupClick(finalI);                }            });        }    }    private void onButtonPopupClick(int buttonId) {        if (numberClick_currentNumber != null) {            // add / remove tile remaining            if (getSudokuGrid().getUserModify(numberClick_currentNumberCoordinate[0],                    numberClick_currentNumberCoordinate[0]).isNumber() &&                    buttonId > 9) {                // if previous number is a number and the next not a number:                getSudokuGrid().addNumberTileRemaining();            } else if (buttonId >= 1 &&                    buttonId <= 9 &&                    !getSudokuGrid().getUserModify(numberClick_currentNumberCoordinate[0],                            numberClick_currentNumberCoordinate[0]).isNumber()) {                // if next number is a number and the previous not a number:                getSudokuGrid().removeNumberTileRemaining();            }            // some actions            if (getSudokuGrid().getUserModify(numberClick_currentNumberCoordinate[0],                    numberClick_currentNumberCoordinate[0]).getNumber() != buttonId) {                // don't add if it the the same                clearRedoList(); // because the undo list change                addUndo(                        new NumberUndoChange(                        numberClick_currentNumberCoordinate[0],                        numberClick_currentNumberCoordinate[1],                        getSudokuGrid().getUserModify(                                numberClick_currentNumberCoordinate[0],                                numberClick_currentNumberCoordinate[1]),                        getSudokuGrid().getColorGrid(                                numberClick_currentNumberCoordinate[0],                                numberClick_currentNumberCoordinate[1])                        )                );                getSudokuGrid().setColorGrid(                        numberClick_currentNumberCoordinate[0],                        numberClick_currentNumberCoordinate[1],                        listColorChoose[getSudokuGrid().getColorChooseSelected()]                );                getSudokuGrid().setUserModify(numberClick_currentNumberCoordinate[0],                        numberClick_currentNumberCoordinate[1], SudokuNumbersEnum.get(buttonId));                updateNumberTile(numberClick_currentNumberCoordinate[0],                        numberClick_currentNumberCoordinate[1]);                updateWinAndConflict();            }            else if (                    getSudokuGrid().getColorGrid(                            numberClick_currentNumberCoordinate[0],                            numberClick_currentNumberCoordinate[1])  !=                    listColorChoose[getSudokuGrid().getColorChooseSelected()]) {                clearRedoList();                addUndo(new ColorUndoChange(                        numberClick_currentNumberCoordinate[0],                        numberClick_currentNumberCoordinate[1],                        getSudokuGrid().getColorGrid(                                numberClick_currentNumberCoordinate[0],                                numberClick_currentNumberCoordinate[1])                ));                getSudokuGrid().setColorGrid(                        numberClick_currentNumberCoordinate[0],                        numberClick_currentNumberCoordinate[1],                        listColorChoose[getSudokuGrid().getColorChooseSelected()]                );                updateNumberTile(numberClick_currentNumberCoordinate[0],                        numberClick_currentNumberCoordinate[1]);            }            popup.dismiss();        }    }    private void updateWinAndConflict() {        if (showConflict) {            new Handler().post(new Runnable() {                @Override                public void run() {                    testWin();                    testConflict(numberClick_currentNumberCoordinate[0],                            numberClick_currentNumberCoordinate[1]);                }            });        } else {            new Handler().post(new Runnable() {                @Override                public void run() {                    testWin();                }            });        }    }    private void testWin() {        if (!getSudokuGrid().isGameFinish() && getSudokuGrid().getNumberTileRemaining() <= 0) {            if (getSudokuGrid().verifyGrid()) {                stopGame(true);            }        }    }    private void resetSudokuGrid() {        getSudokuGrid().resetGrid();        mainGrid.removeAllViews();        clearRedoList();        clearUndoList();        createGridGraphics();    }    private void createGridGraphics() {        final ArrayList<int[]> listCheckConflict = new ArrayList<>(); // 0: x, 1: y        int number_size = (widthToResize - 50) / 9;        mainGrid.setColumnCount(3);        mainGrid.setRowCount(3);        for (int gridLayout = 0; gridLayout < 9; gridLayout++) {            listGridLayout[gridLayout] = new GridLayout(this);            listGridLayout[gridLayout].setBackgroundResource(R.drawable.large_border);            listGridLayout[gridLayout].setPadding(2, 2, 2, 2);            listGridLayout[gridLayout].setRowCount(3);            listGridLayout[gridLayout].setColumnCount(3);            mainGrid.addView(listGridLayout[gridLayout]);            for (int i = 0; i < 9; i++) {                final int x = i % 3 + gridLayout % 3 * 3;                final int y = i / 3 + gridLayout / 3 * 3;                listTileViews[x][y] = new TileView(this);                listTileViews[x][y].setUserModifiable(getSudokuGrid().                        getUserModify(x, y) != SudokuNumbersEnum.NotModifiable);                listTileViews[x][y].setSizeFont(number_size * 0.9f);                listTileViews[x][y].setBackgroundColor(getSudokuGrid().getColorGrid(x, y));                if (getSudokuGrid().getUserModify(x, y) == SudokuNumbersEnum.NotModifiable) {                    listTileViews[x][y].setNumber(getSudokuGrid().get(x, y));                } else if (getSudokuGrid().getUserModify(x, y) == SudokuNumbersEnum.Hint) {                    listTileViews[x][y].setNumber(getSudokuGrid().get(x, y));                    listTileViews[x][y].setNumberFontColor(getResources().getColor(                            R.color.text_hint));                } else {                    listTileViews[x][y].setNumberFontColor(                            getResources().getColor(R.color.user_number_color));                    listTileViews[x][y].setNumber(getSudokuGrid().getUserModify(x, y));                    if (getSudokuGrid().getUserModify(x, y) != SudokuNumbersEnum.Blank) {                        int[] toCheck = new int[2];                        toCheck[0] = x;                        toCheck[1] = y;                        listCheckConflict.add(toCheck);                    }                }                listTileViews[x][y].setOnClickListener(new View.OnClickListener() {                    @Override                    public void onClick(View v) {                        onNumberClick((TileView) v, x, y);                    }                });                CoordinatorLayout.LayoutParams params = new                        CoordinatorLayout.LayoutParams(number_size, number_size);                listTileViews[x][y].setLayoutParams(params);                listGridLayout[gridLayout].addView(listTileViews[x][y]);            }        }        if (showConflict && !listCheckConflict.isEmpty())            new Handler().post(new Runnable() {                @Override                public void run() {                    for (int[] toCheck : listCheckConflict) {                        testConflict(toCheck[0], toCheck[1]);                    }                }            });        undoImageView.setImageDrawable(getSudokuGrid().getUndoList().empty() ?                getResources().getDrawable(R.drawable.ic_action_undo_disable) :                getResources().getDrawable(R.drawable.ic_action_undo));        redoImageView.setImageDrawable(getSudokuGrid().getRedoList().empty() ?                getResources().getDrawable(R.drawable.ic_action_redo_disable) :                getResources().getDrawable(R.drawable.ic_action_redo));    }    private void onNumberClick(TileView tileView, int x, int y) {        if (swapMode) {            if (selectedNumberSwap[0] == x && selectedNumberSwap[1] == y) {                setSwapMode(false);                doColorSwap(getSudokuGrid().getColorGrid(x, y),                        listColorChoose[selectedColorToSwap]);            } else if (selectedColorToSwap != -1) { // verify the color is already select                if (numberClick_currentNumber != null)                    numberClick_currentNumber.setSelected(false);                selectedNumberSwap[0] = x;                selectedNumberSwap[1] = y;                numberClick_currentNumber = tileView;                numberClick_currentNumber.setSelected(true);                informationTextView.setText(R.string.swap_color_confirm_click_ask);            }        } else {            if (getSudokuGrid().getUserModify(x, y).isModifiable()) {                if (numberClick_currentNumber != null)                    numberClick_currentNumber.setSelected(false);                numberClick_currentNumber = tileView;                numberClick_currentNumber.setSelected(true);                numberClick_currentNumberCoordinate[0] = x;                numberClick_currentNumberCoordinate[1] = y;                if (hintMode) {                    if (hintSelectNumber[0] == x && hintSelectNumber[1] == y) {                        // if is the same number / he click twice on it                        setHintMode(false);                        // give hint                        if (!getSudokuGrid().getUserModify(x, y).isNumber())                            getSudokuGrid().removeNumberTileRemaining();                        tileView.setUserModifiable(false);                        tileView.setNumber(getSudokuGrid().get(x, y));                        getSudokuGrid().setUserModify(x, y, SudokuNumbersEnum.Hint);                        tileView.setNumberFontColor(getResources().getColor(R.color.text_hint));                        removeNumberUndoRedo(x, y);                        updateWinAndConflict();                    } else {                        hintSelectNumber[0] = x;                        hintSelectNumber[1] = y;                        informationTextView.setText(R.string.hint_new_click_ask);                    }                } else {                    popup.showAtLocation(mainGrid, Gravity.CENTER, 0, 0);                }            } else {                if (listColorChoose[getSudokuGrid().getColorChooseSelected()] != getSudokuGrid().getColorGrid(x, y)) {                    clearRedoList();                    addUndo(new ColorUndoChange(x, y, getSudokuGrid().getColorGrid(x, y)));                    tileView.setBackgroundColor(listColorChoose[getSudokuGrid().getColorChooseSelected()]);                    getSudokuGrid().setColorGrid(x, y,                            listColorChoose[getSudokuGrid().getColorChooseSelected()]);                }            }        }    }    public void updateNumberTile(int x, int y) {        if (getSudokuGrid().getUserModify(x, y).isModifiable())            listTileViews[x][y].setNumber(getSudokuGrid().getUserModify(x, y));        listTileViews[x][y].setBackgroundColor(getSudokuGrid().getColorGrid(x, y));        listTileViews[x][y].setUserModifiable(getSudokuGrid().getUserModify(x, y).isModifiable());    }    public void testConflict(int tileX, int tileY) {        ArrayList<int[]> toVerify = new ArrayList<>(); // format: 0: type, 1: x, 2: y        // test lines        boolean inConflict = false;        for (int x = 0; x < 9; x++) {            // test if not the same number            if (x != tileX) {                if (getNumberModify(x, tileY) != SudokuNumbersEnum.Blank &&                        getNumberModify(x, tileY)                                ==                                getNumberModify(tileX, tileY)) {                    // same value:                    listTileViews[x][tileY].setConflict(0, true);                    inConflict = true;                } else if (listTileViews[x][tileY].getInConflict(0)) {                    int[] conflict = new int[3];                    /* conflict[0] = 0; already set */                    conflict[1] = x;                    conflict[2] = tileY;                    toVerify.add(conflict);                }            }        }        listTileViews[tileX][tileY].setConflict(0, inConflict);        // test column        inConflict = false;        for (int y = 0; y < 9; y++) {            // test if not the same number            if (y != tileY) {                if (getNumberModify(tileX, y) != SudokuNumbersEnum.Blank &&                        getNumberModify(tileX, y)                                ==                                getNumberModify(tileX, tileY)) {                    // same value:                    listTileViews[tileX][y].setConflict(1, true);                    inConflict = true;                } else if (listTileViews[tileX][y].getInConflict(1)) {                    int[] conflict = new int[3];                    conflict[0] = 1;                    conflict[1] = tileX;                    conflict[2] = y;                    toVerify.add(conflict);                }            }        }        listTileViews[tileX][tileY].setConflict(1, inConflict);        // test square        inConflict = false;        for (int x = tileX / 3 * 3; x < tileX / 3 * 3 + 3; x++) { // loop on square            for (int y = tileY / 3 * 3; y < tileY / 3 * 3 + 3; y++) {                // test if not the same number                if (x != tileX && y != tileY) {                    if (getNumberModify(x, y) != SudokuNumbersEnum.Blank &&                            getNumberModify(x, y)                                    ==                                    getNumberModify(tileX, tileY)) {                        // same value:                        listTileViews[x][y].setConflict(2, true);                        inConflict = true;                    } else if (listTileViews[x][y].getInConflict(2)) {                        int[] conflict = new int[3];                        conflict[0] = 2;                        conflict[1] = x;                        conflict[2] = y;                        toVerify.add(conflict);                    }                }            }        }        listTileViews[tileX][tileY].setConflict(2, inConflict);        // verify numbers        for (int[] conflict : toVerify) {            // conflict format: 0: type, 1: x, 2: y            boolean isInConflict = false;            if (conflict[0] == 0) {                // test line                for (int x = 0; x < 9; x++) {                    if (x != conflict[1]) {                        if (getNumberModify(conflict[1], conflict[2]) ==                                getNumberModify(x, conflict[2])) {                            isInConflict = true;                        }                    }                }            } else if (conflict[0] == 1) {                // test column                for (int y = 0; y < 9; y++) {                    if (y != conflict[2]) {                        if (getNumberModify(conflict[1], conflict[2]) ==                                getNumberModify(conflict[1], y)) {                            isInConflict = true;                        }                    }                }            } else if (conflict[0] == 2) {                // test square                for (int x = tileX / 3 * 3; x < tileX / 3 * 3 + 3; x++) {                    for (int y = tileY / 3 * 3; y < tileY / 3 * 3 + 3; y++) {                        if (x != conflict[1] && y != conflict[2]) {                            if (getNumberModify(conflict[1], conflict[2]) ==                                    getNumberModify(conflict[1], y)) {                                isInConflict = true;                            }                        }                    }                }            }            if (!isInConflict) {                listTileViews[conflict[1]][conflict[2]].setConflict(conflict[0], false);            }        }    }    private void stopGame(boolean win) {        stopGame(win, false);    }    private void stopGame(boolean win, boolean gameAlreadyFinish) {        Log.i("SudokuActivity", "Auto save: stopped");        autoSaveHandler.removeCallbacks(autoSaveRunnable);        if (hintMode)            setHintMode(false);        getSudokuGrid().finishGame();        disableClickListeners();        LinearLayout buttonsChooseColorBar = findViewById(R.id.buttonsChooseColor);        LinearLayout buttonsEndGameBar = findViewById(R.id.buttonsEndGameBar);        findViewById(R.id.buttonActionAbort).setVisibility(View.GONE);        findViewById(R.id.buttonActionHint).setVisibility(View.GONE);        findViewById(R.id.buttonActionUndo).setVisibility(View.GONE);        findViewById(R.id.buttonActionRedo).setVisibility(View.GONE);        findViewById(R.id.buttonActionSwapColor).setVisibility(View.GONE);        if (win && testUserDoGrid()) {            // win            getSudokuGrid().setGameWin(true);            endGameTextView.setText(R.string.game_result_win);            endGameTextView.setTextColor(getResources().getColor(R.color.text_win));            for (int x = 0; x < 9; x++) {                for (int y = 0; y < 9; y++) {                    if (getSudokuGrid().getUserModify(x, y).isModifiable()) {                        listTileViews[x][y].setNumberFontColor(getResources().getColor(                                R.color.text_win));                    }                }            }        } else {            // lose            getSudokuGrid().setGameWin(false);            endGameTextView.setText(R.string.game_result_abort);            endGameTextView.setTextColor(getResources().getColor(R.color.text_lose));            for (int x = 0; x < 9; x++) {                for (int y = 0; y < 9; y++) {                    listTileViews[x][y].setConflict(0, false); // force to remove                    listTileViews[x][y].setConflict(1, false); // conflict (remove the                    listTileViews[x][y].setConflict(2, false); // color)                    if (getSudokuGrid().getUserModify(x, y).isModifiable()) {                        if (getSudokuGrid().getUserModify(x, y) == getSudokuGrid().get(x, y)) {                            listTileViews[x][y].setNumberFontColor(getResources().getColor(                                    R.color.text_win));                        } else {                            listTileViews[x][y].setNumberFontColor(getResources().getColor(                                    R.color.text_lose));                            listTileViews[x][y].setNumber(getSudokuGrid().get(x, y));                        }                    }                }            }        }        endGameTextView.startAnimation(AnimationUtils.loadAnimation(this,                R.anim.end_text_animation));        if (!gameAlreadyFinish) {            colorChooseButtonList[getSudokuGrid().getColorChooseSelected()].animate().setStartDelay(700)                    .setDuration(300).rotation(0);            buttonsChooseColorBar.startAnimation(AnimationUtils.loadAnimation(this,                    R.anim.end_color_buttons_animation));            buttonsEndGameBar.startAnimation(AnimationUtils.loadAnimation(this,                    R.anim.end_buttons_animation));        } else {            buttonsChooseColorBar.setVisibility(View.INVISIBLE);        }        buttonsEndGameBar.setVisibility(View.VISIBLE);        new Handler().post(new Runnable() {            @Override            public void run() {                getSudokuGrid().setStatistics(getStatistics()); // update statistics                ((SudokuApplication) getApplicationContext()).saveStatistics();                ((SudokuApplication) getApplicationContext()).saveGrid();            }        });    }    private boolean testUserDoGrid() {        // verify if the user don't use only hint        for (int x = 0; x < 9; x++) {            for (int y = 0; y < 9; y++) {                if (!getSudokuGrid().getUserModify(x, y).isModifiable()) { // if the user do that                    return true;                }            }        }        return false;    }    private void disableClickListeners() {        for (int x = 0; x < 9; x++) {            for (int y = 0; y < 9; y++) {                listTileViews[x][y].setOnClickListener(null);                listTileViews[x][y].setBackgroundColor(Color.WHITE);            }        }    }    private void setHintMode(boolean hintMode) {        this.hintMode = hintMode;        if (swapMode)            setSwapMode(false);        if (hintMode) {            informationTextView.setText(R.string.hint_mode_text);            informationTextView.startAnimation(AnimationUtils.loadAnimation(this,                    R.anim.information_text_animation));            hintSelectNumber[0] = -1;            hintSelectNumber[1] = -1;        } else {            informationTextView.setText("");            if (numberClick_currentNumber != null)                numberClick_currentNumber.setSelected(false);        }    }    private void setSwapMode(boolean swapMode) {        if (hintMode)            setHintMode(false);        if (swapMode) {            disabledColorButton();            informationTextView.setText(R.string.swap_color_choose_color);            informationTextView.startAnimation(AnimationUtils.loadAnimation(this,                    R.anim.information_text_animation));            selectedNumberSwap[0] = -1;            selectedNumberSwap[1] = -1;            selectedColorToSwap = -1;        } else {            enabledColorButton();            informationTextView.setText("");            if (numberClick_currentNumber != null)                numberClick_currentNumber.setSelected(false);        }        this.swapMode = swapMode;    }    private void doColorSwap(int firstColor, int secondColor) {        ArrayList<int[]> listColorChange = new ArrayList<>();        for (int x = 0; x < 9; x++) {            for (int y = 0; y < 9; y++) {                if (getSudokuGrid().getColorGrid(x, y) == firstColor) {                    int[] numberModify = new int[]{x, y};                    Log.i("SudokuActivity", "X: " + x + " Y:" + y + " Color1: " + firstColor + " Color2 " + secondColor);                    listColorChange.add(numberModify);                    getSudokuGrid().setColorGrid(x, y, secondColor);                    updateNumberTile(x, y);                }            }        }        clearRedoList();        addUndo(new SwapColorUndoChange(listColorChange, firstColor, secondColor));    }    private void addUndo(UndoChange change) {        getSudokuGrid().getUndoList().add(change);        if (getSudokuGrid().getUndoList().size() > MAX_UNDO) {            getSudokuGrid().getUndoList().remove(0);        } else if (getSudokuGrid().getUndoList().size() == 1)            undoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_undo));    }    private void removeUndo(UndoChange numberUndoChange) {        getSudokuGrid().getUndoList().remove(numberUndoChange);        if (getSudokuGrid().getUndoList().empty())            undoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_undo_disable));    }    private void clearUndoList() {        if (!getSudokuGrid().getUndoList().empty()) {            getSudokuGrid().getUndoList().clear();            undoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_undo_disable));        }    }    private void removeNumberUndoRedo(int x, int y) {        ArrayList<UndoChange> toRemove = new ArrayList<>();        for (UndoChange numberUndoChange : getSudokuGrid().getUndoList()) {            if (numberUndoChange.getClass().isInstance(NumberUndoChange.class)) {                if (((NumberUndoChange) numberUndoChange).getX() == x &&                        ((NumberUndoChange) numberUndoChange).getY() == y) {                    toRemove.add(numberUndoChange);                }            }        }        for (UndoChange remove : toRemove) {            removeUndo(remove);        }        toRemove.clear();        for (UndoChange numberUndoChange : getSudokuGrid().getRedoList()) {            if (numberUndoChange.getClass().isInstance(NumberUndoChange.class)) {                if (((NumberUndoChange) numberUndoChange).getX() == x &&                        ((NumberUndoChange) numberUndoChange).getY() == y) {                    toRemove.add(numberUndoChange);                }            }        }        for (UndoChange remove : toRemove) {            removeRedo(remove);        }    }    private void addRedo(UndoChange change) {        getSudokuGrid().getRedoList().add(change);        if (getSudokuGrid().getRedoList().size() > MAX_UNDO) {            getSudokuGrid().getRedoList().remove(0);        } else if (getSudokuGrid().getRedoList().size() == 1)            redoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_redo));    }    private void removeRedo(UndoChange numberUndoChange) {        getSudokuGrid().getRedoList().remove(numberUndoChange);        if (getSudokuGrid().getRedoList().empty())            redoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_redo_disable));    }    private void clearRedoList() {        if (!getSudokuGrid().getRedoList().empty()) {            getSudokuGrid().getRedoList().clear();            redoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_redo_disable));        }    }    private void createChooseColorButton() {        LinearLayout listButtons = findViewById(R.id.buttonsChooseColor);        for (int index = 0; index < listColorChoose.length; index++) {            Button button = (Button) getLayoutInflater().inflate(R.layout.button_choose_color_layout,                    listButtons, false);            final int buttonId = index;            button.setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View view) {                    chooseColorButtonOnClick(buttonId);                }            });            button.setBackgroundColor(listColorChooseButtonColor[index]);            colorChooseButtonList[index] = button;            listButtons.addView(button);        }        colorChooseButtonList[getSudokuGrid().getColorChooseSelected()].setRotation(45);    }    private void chooseColorButtonOnClick(int id) {        if (swapMode) {            if (id != selectedColorToSwap) {                if (selectedColorToSwap != -1)                    colorChooseButtonList[selectedColorToSwap]                            .animate()                            .rotation(0)                            .setDuration(300);                selectedColorToSwap = id;                colorChooseButtonList[selectedColorToSwap]                        .animate()                        .rotation(45)                        .setDuration(300);                informationTextView.setText(R.string.swap_color_choose_number);            }        } else {            if (id != getSudokuGrid().getColorChooseSelected()) {                colorChooseButtonList[getSudokuGrid().getColorChooseSelected()]                        .animate()                        .rotation(0)                        .setDuration(300);                getSudokuGrid().setColorChooseSelected(id);                colorChooseButtonList[getSudokuGrid().getColorChooseSelected()]                        .animate()                        .rotation(45)                        .setDuration(300);            }        }    }    private void disabledColorButton() {        if (swapMode) {            colorChooseButtonList[selectedColorToSwap]                    .animate()                    .rotation(0)                    .setDuration(300);        } else {            colorChooseButtonList[getSudokuGrid().getColorChooseSelected()]                    .animate()                    .rotation(0)                    .setDuration(300);        }    }    private void enabledColorButton() {        if (swapMode) {            if (selectedColorToSwap != -1) {                colorChooseButtonList[selectedColorToSwap]                        .animate()                        .rotation(0)                        .setDuration(300);            }            colorChooseButtonList[getSudokuGrid().getColorChooseSelected()]                    .animate()                    .rotation(45)                    .setDuration(300);        } else {            colorChooseButtonList[getSudokuGrid().getColorChooseSelected()]                    .animate()                    .rotation(45)                    .setDuration(300);        }    }    private SudokuGrid getSudokuGrid() {        return ((SudokuApplication) getApplicationContext()).getCurrentSudokuGrid();    }    private void setSudokuGrid(SudokuGrid sudokuGrid) {        ((SudokuApplication) getApplicationContext()).setCurrentSudokuGrid(sudokuGrid);    }    private SudokuStatistics getStatistics() {        return ((SudokuApplication) getApplicationContext()).getSudokuGlobalStatistics();    }    private String getGridId() {        NumberFormat numberFormat = NumberFormat.getInstance(getResources().getConfiguration()                .locale);        numberFormat.setGroupingUsed(true);        return String.valueOf(getSudokuGrid().getNumberTileToRemove()) + '-' +                numberFormat.format(getSudokuGrid().getSeed());    }        private SudokuNumbersEnum getNumberModify(int x, int y) {        if (getSudokuGrid().getUserModify(x, y).isModifiable()) {            return getSudokuGrid().getUserModify(x, y);        } else {            return getSudokuGrid().get(x, y);        }    }}