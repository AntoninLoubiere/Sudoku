package fr.pyjacpp.sudoku;import android.annotation.SuppressLint;import android.app.Dialog;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.graphics.Point;import android.os.Bundle;import android.support.design.widget.CoordinatorLayout;import android.support.v7.app.AlertDialog;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.Gravity;import android.view.LayoutInflater;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.animation.AnimationUtils;import android.widget.Button;import android.widget.GridLayout;import android.widget.PopupWindow;import android.widget.RadioButton;import android.widget.TextView;import java.util.ArrayList;import java.util.Random;public class SudokuActivity extends AppCompatActivity {    private TileView popup_currentTile = null;    private int[] popup_currentTileCoord = new int[2];    private PopupWindow popup = new PopupWindow();    private GridLayout[] listGridLayout = new GridLayout[9];    GridLayout mainGrid;    private int[][] sudokuGrid = new int[9][9];    private TileView[][] listTileViews = new TileView[9][9];    private boolean[][] toFindTiles = new boolean[9][9];    private int numberTileToRemove = 40;    private int numberTileremaining = 0;    private boolean showConflict = true;    private boolean gameFinish = false;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        numberTileToRemove = getIntent().getIntExtra("numberTilesToRemove",                40);        showConflict = getIntent().getBooleanExtra("showConflictSwitch",                showConflict);        setContentView(R.layout.activity_sudoku);        mainGrid = findViewById(R.id.sudoku_mainLayout);        findViewById(R.id.newGameButton).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                newGame();            }        });        findViewById(R.id.mainMenuButton).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                finish();            }        });        Log.i("SudokuActivity", "Start to created the grid");        initGrid();        createGrid();        removeSomeTiles();        popup_Create();        createGridGraphics();        Log.i("SudokuActivity", "The grid and graphics were created");    }    @Override    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.activity_sudoku, menu);        return super.onCreateOptionsMenu(menu);    }    @Override    public boolean onOptionsItemSelected(MenuItem item) {        switch (item.getItemId()) {            case R.id.mainMenu_actionMenu:                if (gameFinish) {                    finish();                } else {                    new AlertDialog.Builder(this)                            .setTitle(R.string.dialog_main_menu_title)                            .setMessage(R.string.dialog_main_menu_message)                            .setNegativeButton(R.string.dialog_main_menu_no, null)                            .setPositiveButton(R.string.dialog_main_menu_yes, new                                    DialogInterface.OnClickListener() {                                        @Override                                        public void onClick(DialogInterface dialog, int which) {                                            finish();                                        }                                    })                            .show();                }                return true;            case R.id.restart_actionMenu:                if (gameFinish) {                    newGame();                } else {                    final Dialog dialog = new Dialog(this);                    dialog.setTitle(R.string.dialog_restart_title);                    dialog.setContentView(R.layout.dialog_restart_game);                    final RadioButton restartThisGameButton = dialog.findViewById(R.id.restartThisGameButton);                    final RadioButton restartNewGameButton = dialog.findViewById(R.id.restartNewGameButton);                    dialog.findViewById(R.id.validButton).setOnClickListener(new View.OnClickListener() {                        @Override                        public void onClick(View v) {                            if (restartThisGameButton.isChecked()) {                                reinitSudokuGrid();                            } else if (restartNewGameButton.isChecked()) {                                newGame();                            }                            dialog.dismiss();                        }                    });                    dialog.findViewById(R.id.cancelButton).setOnClickListener(new View.OnClickListener() {                        @Override                        public void onClick(View v) {                            dialog.dismiss();                        }                    });                    dialog.show();                }                return true;            case R.id.abort_actionMenu:                if (!gameFinish) {                    new AlertDialog.Builder(this)                            .setTitle(R.string.dialog_abort_title)                            .setMessage(R.string.dialog_abort_message)                            .setPositiveButton(R.string.dialog_abort, new                                    DialogInterface.OnClickListener() {                                        @Override                                        public void onClick(DialogInterface dialog, int which) {                                            stopGame(false);                                        }                                    })                            .setNegativeButton(R.string.dialog_cancel, null)                            .show();                }                return true;            default:                return super.onOptionsItemSelected(item);        }    }    private void newGame() {        Intent intent = new Intent(getApplicationContext(),                ConfigureSudokuGridActivity.class);        intent.putExtra("numberTilesToRemove", numberTileToRemove);        intent.putExtra("showConflictSwitch", showConflict);        startActivity(intent);        finish();    }    private void popup_Create() {        LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);        assert inflater != null;        @SuppressLint("InflateParams")        View customView = inflater.inflate(R.layout.layout_popup, null);        popup = new PopupWindow(customView,                CoordinatorLayout.LayoutParams.WRAP_CONTENT,                CoordinatorLayout.LayoutParams.WRAP_CONTENT);        popup.setOutsideTouchable(true);        popup.setFocusable(true);        popup.setBackgroundDrawable(getResources().getDrawable(R.drawable.popup_border));        popup.setOnDismissListener(new PopupWindow.OnDismissListener() {            @Override            public void onDismiss() {                if (popup_currentTile != null)                    popup_currentTile.setSelected(false);            }        });        final Button[] popupButton = new Button[12];        popupButton[0] = popup.getContentView().findViewById(R.id.Button1);        popupButton[1] = popup.getContentView().findViewById(R.id.Button2);        popupButton[2] = popup.getContentView().findViewById(R.id.Button3);        popupButton[3] = popup.getContentView().findViewById(R.id.Button4);        popupButton[4] = popup.getContentView().findViewById(R.id.Button5);        popupButton[5] = popup.getContentView().findViewById(R.id.Button6);        popupButton[6] = popup.getContentView().findViewById(R.id.Button7);        popupButton[7] = popup.getContentView().findViewById(R.id.Button8);        popupButton[8] = popup.getContentView().findViewById(R.id.Button9);        popupButton[9] = popup.getContentView().findViewById(R.id.ButtonSquare);        popupButton[10] = popup.getContentView().findViewById(R.id.ButtonNothing);        popupButton[11] = popup.getContentView().findViewById(R.id.ButtonCircle);        for (int i = 0; i < popupButton.length; i ++) {            final int finalI = i;            popupButton[i].setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    onButtonPopupClick(finalI);                }            });        }    }            private void onButtonPopupClick(int buttonId) {        if (popup_currentTile != null) {            if (popup_currentTile.getNumber() <= 9 && buttonId + 1 > 9) {                // if previous number is a number and the next not a number:                numberTileremaining++;            } else if (buttonId + 1 <= 9 && popup_currentTile.getNumber() > 9) {                // if next number is a number and the previous not a number:                numberTileremaining--;            }            popup_currentTile.setNumber(buttonId + 1);            if (showConflict) {                new Thread(new Runnable() {                    @Override                    public void run() {                        testWin();                        testConflict(popup_currentTileCoord[0],                                popup_currentTileCoord[1]);                    }                }).run();            } else {                new Thread(new Runnable() {                    @Override                    public void run() {                        testWin();                    }                }).run();            }            popup.dismiss();        }    }    private void testWin() {        if (numberTileremaining == 0) {            if (verifyGrid()) {                stopGame(true);            }        }    }    private void reinitSudokuGrid() {        mainGrid.removeAllViews();        createGridGraphics();    }    private void initGrid() {        for (int x = 0; x < 3; x++) {            for (int y = 0; y < 3; y++) {                sudokuGrid[x][y] = 0;            }        }    }    private void createGrid() {        SudokuGridGenerator sudokuGridGenerator = new SudokuGridGenerator();        int[] sudokuGridCreated;        do {            sudokuGridCreated = sudokuGridGenerator.generateGrid();        } while (!SudokuGridGenerator.isPerfect(sudokuGridCreated));        // SudokuGridGenerator.printGrid(sudokuGridCreated);        // convert grid        for (int i = 0; i < 81; i++) {            sudokuGrid[i / 9][i % 9] = sudokuGridCreated[i];        }    }    private void createGridGraphics() {        Point size = new Point();        getWindowManager().getDefaultDisplay().getSize(size);        int width = size.x;        int height = size.y;        int min = width > height ? height : width; // get min        int number_size = (min - 50) / 9;        mainGrid.setColumnCount(3);        mainGrid.setRowCount(3);        for (int gridLayout = 0; gridLayout < 9; gridLayout++) {            listGridLayout[gridLayout] = new GridLayout(this);            listGridLayout[gridLayout].setBackgroundResource(R.drawable.large_border);            listGridLayout[gridLayout].setPadding(2, 2, 2, 2);            listGridLayout[gridLayout].setRowCount(3);            listGridLayout[gridLayout].setColumnCount(3);            mainGrid.addView(listGridLayout[gridLayout]);            for (int i = 0; i < 9; i++) {                final int x = i % 3  + gridLayout % 3 * 3;                final int y = i / 3 + gridLayout / 3 * 3;                listTileViews[x][y] = new TileView(this);                listTileViews[x][y].setUserModifiable(toFindTiles[x][y]);                listTileViews[x][y].setSizeFont(number_size * 0.9f);                if (toFindTiles[x][y]) {                    listTileViews[x][y].setNumber(11);                    listTileViews[x][y].setOnClickListener(new View.OnClickListener() {                        @Override                        public void onClick(View v) {                            onNumberClick((TileView) v, x, y);                        }                    });                    listTileViews[x][y].setNumberFontColor(                            getResources().getColor(R.color.user_number_color));                } else {                    listTileViews[x][y].setNumber(sudokuGrid[x][y]);                }                CoordinatorLayout.LayoutParams params = new                        CoordinatorLayout.LayoutParams(number_size, number_size);                listTileViews[x][y].setLayoutParams(params);                listGridLayout[gridLayout].addView(listTileViews[x][y]);            }        }    }    private void onNumberClick(TileView tileView, int x, int y) {        if (popup_currentTile != null)            popup_currentTile.setSelected(false);        popup_currentTile = tileView;        popup_currentTileCoord[0] = x;        popup_currentTileCoord[1] = y;        popup_currentTile.setSelected(true);        popup.showAtLocation(mainGrid, Gravity.CENTER, 0, 0);    }    private void removeSomeTiles() {        Random random = new Random();        int numberDisable = 0;        while (numberDisable < numberTileToRemove / 2) {            int x = random.nextInt(9);            int y = random.nextInt(9);            if (!toFindTiles[x][y]) {                int reverseX = x * -1 + 8;                int reverseY = y *-1 + 8;                toFindTiles[x][y] = true;                toFindTiles[reverseX][reverseY] = true;                if (x == reverseX && reverseY == y) // same tile                    numberTileremaining += 1;                else                    numberTileremaining += 2;                numberDisable++;            }        }    }    private boolean verifyGrid() {        // test lines        for (int y = 0; y < 9; y++) {            // reset            boolean[] numberExist = {                    false, false, false,                    false, false, false,                    false, false, false};            for (int x = 0; x < 9; x++) {                if (!numberExist[listTileViews[x][y].getNumber() - 1]) {                    numberExist[listTileViews[x][y].getNumber() - 1] = true;                } else {                    return false;                }            }        }        // reset        // test column        for (int x = 0; x < 9; x++) {            // reset            boolean[] numberExist = {                    false, false, false,                    false, false, false,                    false, false, false};            for (int y = 0; y < 9; y++) {                if (!numberExist[listTileViews[x][y].getNumber() - 1]) {                    numberExist[listTileViews[x][y].getNumber() - 1] = true;                } else {                    return false;                }            }        }        // test sqaure        for (int sqaure = 0; sqaure < 9; sqaure++) {            // reset            boolean[] numberExist = {                    false, false, false,                    false, false, false,                    false, false, false};            for (int x = sqaure % 3 * 3; x < sqaure % 3 * 3 + 3; x++) {                for (int y = sqaure / 3 * 3; y < sqaure / 3 * 3; y++) {                    if (!numberExist[listTileViews[x][y].getNumber() - 1]) {                        numberExist[listTileViews[x][y].getNumber() - 1] = true;                    } else {                        return false;                    }                }            }        }        return true;    }    private void testConflict(int tileX, int tileY) {        ArrayList<int[]> toVerify = new ArrayList<>(); // format: 0: type, 1: x, 2: y        Log.i("SudokuActivity", "Test conflict");        // test lines        boolean inConflict = false;        for (int x = 0; x < 9; x++) {            // test if not the same number            if (x != tileX) {                if (listTileViews[x][tileY].getNumber() != 11 &&                        listTileViews[x][tileY].getNumber() == listTileViews[tileX][tileY].getNumber()) {                    // same value:                    listTileViews[x][tileY].setConflict(0, true);                    inConflict = true;                } else if (listTileViews[x][tileY].getInConflict(0)) {                    int[] conflict = new int[3];                    /* conflict[0] = 0; aleraedy set */ conflict[1] = x; conflict[2] = tileY;                    toVerify.add(conflict);                }            }        }        listTileViews[tileX][tileY].setConflict(0, inConflict);        // test column        inConflict = false;        for (int y = 0; y < 9; y++) {            // test if not the same number            if (y != tileY) {                if (listTileViews[tileX][y] .getNumber() != 11 &&                        listTileViews[tileX][y] .getNumber() == listTileViews[tileX][tileY]                        .getNumber()) {                    // same value:                    listTileViews[tileX][y].setConflict(1, true);                    inConflict = true;                } else if (listTileViews[tileX][y].getInConflict(1)) {                    int[] conflict = new int[3];                    conflict[0] = 1; conflict[1] = tileX; conflict[2] = y;                    toVerify.add(conflict);                }            }        }        listTileViews[tileX][tileY].setConflict(1, inConflict);        // test square        inConflict = false;        for (int x = tileX / 3 * 3; x < tileX / 3 * 3 + 3; x++) { // loop on sqaure            for (int y = tileY / 3 *3; y < tileY / 3 *3 + 3; y++) {                // test if not the same number                if (x != tileX && y != tileY) {                    if (listTileViews[x][y].getNumber() != 11 &&                            listTileViews[x][y].getNumber() == listTileViews[tileX][tileY]                            .getNumber()) {                        // same value:                        listTileViews[x][y].setConflict(2, true);                        inConflict = true;                    } else if (listTileViews[x][y].getInConflict(2)) {                        int[] conflict = new int[3];                        conflict[0] = 2; conflict[1] = x; conflict[2] = y;                        toVerify.add(conflict);                    }                }            }        }        listTileViews[tileX][tileY].setConflict(2, inConflict);        // verify numbers        for (int[] conflict : toVerify) {            // conflict format: 0: type, 1: x, 2: y            boolean isInConflict = false;            if (conflict[0] == 0) {                // test line                for (int x = 0; x < 9; x++) {                    if (x != conflict[1]) {                        if (listTileViews[conflict[1]][conflict[2]].getNumber() ==                                listTileViews[x][conflict[2]].getNumber()) {                            isInConflict = true;                        }                    }                }            } else if (conflict[0] == 1) {                // test column                for (int y = 0; y < 9; y++) {                    if (y != conflict[2]) {                        if (listTileViews[conflict[1]][conflict[2]].getNumber() ==                                listTileViews[conflict[1]][y].getNumber()) {                            isInConflict = true;                        }                    }                }            } else if (conflict[0] == 2) {                // test sqaure                for (int x = tileX / 3 * 3; x < tileX / 3 * 3 + 3; x++) {                    for (int y = tileY / 3 *3; y < tileY / 3 *3 + 3; y++) {                        if (x != conflict[1] && y != conflict[2]) {                            if (listTileViews[conflict[1]][conflict[2]].getNumber() ==                                    listTileViews[conflict[1]][y].getNumber()) {                                isInConflict = true;                            }                        }                    }                }            }            if (!isInConflict) {                listTileViews[conflict[1]][conflict[2]].setConflict(conflict[0], false);            }        }    }    private void stopGame(boolean win) {        gameFinish = true;        findViewById(R.id.buttonsEndGameBar).setVisibility(View.VISIBLE);        disableClickListeners();        TextView textResult = findViewById(R.id.textViewResultGame);        if (win) {            // win            textResult.setText(R.string.game_result_win);            textResult.setTextColor(getResources().getColor(R.color.text_win));            for (int x = 0; x < 9; x++) {                for (int y = 0; y < 9; y++) {                    if (listTileViews[x][y].isUserModifiable()) {                        listTileViews[x][y].setNumberFontColor(getResources().getColor(                                R.color.text_win));                    }                }            }        } else {            // lose            textResult.setText(R.string.game_result_abort);            textResult.setTextColor(getResources().getColor(R.color.text_lose));            for (int x = 0; x < 9; x++) {                for (int y = 0; y < 9; y++) {                    listTileViews[x][y].setConflict(0, false); // force to remove                    listTileViews[x][y].setConflict(1, false); // conflict (remove the                    listTileViews[x][y].setConflict(2, false); // color)                    if (listTileViews[x][y].isUserModifiable()) {                        if (listTileViews[x][y].getNumber() == sudokuGrid[x][y]) {                            listTileViews[x][y].setNumberFontColor(getResources().getColor(                                    R.color.text_win));                        } else {                            listTileViews[x][y].setNumberFontColor(getResources().getColor(                                    R.color.text_lose));                            listTileViews[x][y].setNumber(sudokuGrid[x][y]);                        }                    }                }            }        }        textResult.startAnimation(AnimationUtils.loadAnimation(this,                R.anim.end_text_animation));    }    private void disableClickListeners() {        for (int x = 0; x < 9; x++) {            for (int y = 0; y < 9; y++) {                listTileViews[x][y].setOnClickListener(null);            }        }    }}