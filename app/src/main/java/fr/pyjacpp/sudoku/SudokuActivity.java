package fr.pyjacpp.sudoku;import android.annotation.SuppressLint;import android.app.Dialog;import android.content.ClipData;import android.content.ClipboardManager;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.graphics.Color;import android.os.Bundle;import android.os.Handler;import android.support.design.widget.CoordinatorLayout;import android.support.v7.app.AlertDialog;import android.support.v7.app.AppCompatActivity;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.view.animation.AnimationUtils;import android.widget.Button;import android.widget.GridLayout;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.PopupWindow;import android.widget.RadioButton;import android.widget.TextView;import android.widget.Toast;import java.text.NumberFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.TimeUnit;import fr.pyjacpp.sudoku.sudoku_grid.SudokuGrid;import fr.pyjacpp.sudoku.sudoku_grid.SudokuNumberList;import fr.pyjacpp.sudoku.sudoku_grid.SudokuNumbersEnum;import fr.pyjacpp.sudoku.undochange.UndoChange;import fr.pyjacpp.sudoku.undochange.UndoEnum;public class SudokuActivity extends AppCompatActivity {    private final static int DELAY_AUTO_SAVE = 60 * 1000;    private final static int MAX_UNDO = 200;    private final static int DELAY_DOUBLE_CLICK = 350;    private final static int[] listColorChoose = {            Color.parseColor("#debaba"),            Color.parseColor("#ded5ba"),            Color.parseColor("#ccdeba"),            Color.parseColor("#badec3"),            Color.parseColor("#badede"),            Color.parseColor("#bac3de"),            Color.parseColor("#ccbade"),            Color.parseColor("#debad5"),            Color.parseColor("#ffffff"),    };    private final static int[] listColorChooseButtonColor = {            Color.parseColor("#c58787"),            Color.parseColor("#c5b587"),            Color.parseColor("#a6c587"),            Color.parseColor("#87c596"),            Color.parseColor("#87c5c5"),            Color.parseColor("#8796c5"),            Color.parseColor("#a687c5"),            Color.parseColor("#c587b5"),            Color.parseColor("#C4C4C4"),    };    private final ButtonPopupNumber[] popupButton = new ButtonPopupNumber[12];    private final int[] numberClick_currentNumberCoordinate = new int[2];    private final GridLayout[] listGridLayout = new GridLayout[9];    private final TileView[][] listTileViews = new TileView[9][9];    private final ArrayList<SudokuNumbersEnum> buttonPopupSelectedNumbers = new ArrayList<>();    private final int[] hintSelectNumber = new int[2];    private final int[] selectedNumberSwap = new int[]{-1, -1};    private final Button[] colorChooseButtonList = new Button[listColorChoose.length];    private Handler autoSaveHandler;    private GridLayout mainGrid;    private TileView numberClick_currentNumber = null;    private PopupWindow popup = new PopupWindow();    private TextView informationTextView;    private TextView endGameTextView;    private ImageView undoImageView;    private ImageView redoImageView;    private TextView timeTextView;    private int lastButtonPopupClickId = -1;    private long lastButtonPopupClickDelay = 0;    private boolean showConflict = true;    private boolean hintMode = false;    private boolean swapMode = false;    private int selectedColorToSwap = -1;    private int widthToResize;    private SudokuGrid sudokuGrid;    private Timer timer;    private final Runnable autoSaveRunnable = new Runnable() {        @Override        public void run() {            SudokuGrid sudokuGrid = getSudokuGrid();            if (sudokuGrid != null) {                // Log.i("SudokuActivity", "Auto save: Save the grid"); // LOG_DISABLED                ((SudokuApplication) getApplicationContext()).saveGrid();                sudokuGrid.reCalculateNumberNumberRemaining();                sudokuGrid.checkPointResolveTime();                testWin();                if (!sudokuGrid.isGameFinish())                    autoSaveHandler.postDelayed(autoSaveRunnable, DELAY_AUTO_SAVE);            }        }    };    private ImageView pause;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        autoSaveHandler = new Handler(getMainLooper());        Intent intent = getIntent();        showConflict = intent.getBooleanExtra("showConflictSwitch",                showConflict);        setContentView(R.layout.activity_sudoku);        if (getSupportActionBar() != null) {            getSupportActionBar().setDisplayHomeAsUpEnabled(true);            getSupportActionBar().setDisplayShowHomeEnabled(true);        }        mainGrid = findViewById(R.id.sudoku_mainLayout);        informationTextView = findViewById(R.id.informationTextView);        endGameTextView = findViewById(R.id.endTextView);        timeTextView = findViewById(R.id.timeTextView);        undoImageView = findViewById(R.id.buttonActionUndo);        redoImageView = findViewById(R.id.buttonActionRedo);        findViewById(R.id.newGameButton).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                newGame();            }        });        findViewById(R.id.mainMenuButton).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                finish();            }        });        // resize widgets        widthToResize = getWidth();        // create grid        // Log.i("SudokuActivity", "Start to created the grid"); // LOG_DISABLED        sudokuGrid = getSudokuGrid();        if (sudokuGrid == null) {            finish();            return;        }        timer = new Timer();        // show seed        TextView seedTextView = findViewById(R.id.seedTextView);        seedTextView.setText(String.format(getResources().getString(R.string.seed_text), getGridId()));        seedTextView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                ClipboardManager clipboardManager = (ClipboardManager)                        getSystemService(CLIPBOARD_SERVICE);                ClipData data = ClipData.newPlainText("gridId", getGridId());                clipboardManager.setPrimaryClip(data);                Toast.makeText(SudokuActivity.this, getString(R.string.id_grid_copy),                        Toast.LENGTH_LONG).show();            }        });        popupCreate();        createChooseColorButton();        createGridGraphics();        configureActionButtons();        if (sudokuGrid.isGameFinish()) {            stopGame(sudokuGrid.isGameWin(), true);        }        // Log.i("SudokuActivity", "The grid and graphics were created"); // LOG_DISABLED    }    private int getWidth() {        return getDisplay().getWidth();    }    @Override    public void onBackPressed() {        mainMenuPopupAsk();    }    @Override    public boolean onSupportNavigateUp() {        mainMenuPopupAsk();        return true;    }    @Override    protected void onResume() {        // startGrid auto save        if (!sudokuGrid.isGameFinish()) {            if (!sudokuGrid.isPaused()) sudokuGrid.resumeGrid();            // Log.i("SudokuActivity", "Auto save: started"); // LOG_DISABLED            autoSaveHandler.postDelayed(autoSaveRunnable, DELAY_AUTO_SAVE);            if (sudokuGrid.getTimerSettings() == SudokuApplication.TIMER_SHOW) {                timer.scheduleAtFixedRate(new TimerTask() {                    @Override                    public void run() {                        updateTimeView(false);                    }                }, 0, 1000);            }        }        super.onResume();    }    @Override    protected void onPause() {        // Log.i("SudokuActivity", "Auto save: stopped"); // LOG_DISABLED        if (!sudokuGrid.isGameFinish() && !sudokuGrid.isPaused()) sudokuGrid.pauseGrid();        new Thread(new Runnable() {            @Override            public void run() {                ((SudokuApplication) getApplicationContext()).saveGrid();            }        }).start();        autoSaveHandler.removeCallbacks(autoSaveRunnable);        timer.purge();        super.onPause();    }    private void mainMenuPopupAsk() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        if (sudokuGrid.isGameFinish()) {            finish();        } else {            new AlertDialog.Builder(this)                    .setTitle(R.string.dialog_main_menu_title)                    .setMessage(R.string.dialog_main_menu_message)                    .setNegativeButton(R.string.dialog_main_menu_no, null)                    .setPositiveButton(R.string.dialog_main_menu_yes, new                            DialogInterface.OnClickListener() {                                @Override                                public void onClick(DialogInterface dialog, int which) {                                    finish();                                }                            })                    .show();        }    }    private void configureActionButtons() {        ImageView abort = findViewById(R.id.buttonActionAbort);        // ImageView verifyGrid = findViewById(R.id.buttonActionVerifyGrid);        ImageView hint = findViewById(R.id.buttonActionHint);        ImageView swapColor = findViewById(R.id.buttonActionSwapColor);        ImageView restart = findViewById(R.id.buttonActionRestart);        pause = findViewById(R.id.buttonActionPause);        updatePaused();        abort.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(final View v) {                abortButtonOnClick();            }        });        /*verifyGrid.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                verifyGridButtonOnClick();            }        });*/        hint.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                hintButtonClick();            }        });        swapColor.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                swapColorButtonClick();            }        });        restart.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                restartButtonOnClick();            }        });        pause.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                pauseButtonOnClick();            }        });        undoImageView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                undoMenuButtonClick();            }        });        redoImageView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                redoMenuButtonClick();            }        });        // long click        abort.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });/*        verifyGrid.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });*/        hint.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        swapColor.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        undoImageView.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        redoImageView.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        restart.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });        pause.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View view) {                Toast.makeText(SudokuActivity.this, view.getContentDescription(),                        Toast.LENGTH_SHORT).show();                return true;            }        });    }    private void abortButtonOnClick() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        if (!sudokuGrid.isGameFinish()) {            new AlertDialog.Builder(this)                    .setTitle(R.string.dialog_abort_title)                    .setMessage(R.string.dialog_abort_message)                    .setPositiveButton(R.string.dialog_abort, new                            DialogInterface.OnClickListener() {                                @Override                                public void onClick(DialogInterface dialog, int which) {                                    stopGame(false);                                }                            })                    .setNegativeButton(R.string.dialog_cancel, null)                    .show();        }    }    /*private void verifyGridButtonOnClick() {        if (sudokuGrid.verifyGrid()) {            stopGame(true);        }        else {            sudokuGrid.reCalculateNumberNumberRemaining();        }    }*/    private void updateTimeView(boolean end) {        if (swapMode || hintMode) return;        long resolveTime = sudokuGrid.getResolveTimeAndCheckpoint();        long diffInHours = TimeUnit.MILLISECONDS.toHours(resolveTime);        long diffInMin = TimeUnit.MILLISECONDS.toMinutes(resolveTime) % 60;        long diffInSec = TimeUnit.MILLISECONDS.toSeconds(resolveTime) % 60;        final StringBuilder stringBuilder = new StringBuilder();        String s;        if (diffInHours > 0) {            s = String.valueOf(diffInHours);            if (s.length() < 2) {                stringBuilder.append('0');            }            stringBuilder.append(s);            stringBuilder.append(':');        }        s = String.valueOf(diffInMin);        if (s.length() < 2) stringBuilder.append("0");        stringBuilder.append(s);        stringBuilder.append(':');        s = String.valueOf(diffInSec);        if (s.length() < 2) stringBuilder.append("0");        stringBuilder.append(s);        if (end) {            stringBuilder.append('.');            stringBuilder.append(resolveTime % 1000 / 10);        }        // Log.i("SUDOKU_DEBUG", stringBuilder.toString() + " - " + diffInSec);        timeTextView.post(new Runnable() {            @Override            public void run() {                timeTextView.setText(stringBuilder.toString());            }        });    }    private void hintButtonClick() {        if (sudokuGrid.isPaused()) return;        if (swapMode)            setSwapMode(false);        if (!sudokuGrid.isGameFinish()) {            setHintMode(!hintMode);        }    }    private void swapColorButtonClick() {        if (sudokuGrid.isPaused()) return;        if (hintMode)            setHintMode(false);        if (!sudokuGrid.isGameFinish())            setSwapMode(!swapMode);    }    private void restartButtonOnClick() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        if (sudokuGrid.isGameFinish()) {            newGame();        } else {            final Dialog dialog = new Dialog(this);            dialog.setTitle(R.string.dialog_restart_title);            dialog.setCanceledOnTouchOutside(true);            dialog.setContentView(R.layout.dialog_restart_game);            final RadioButton restartThisGameButton = dialog.findViewById(R.id.restartThisGameButton);            final RadioButton restartNewGameButton = dialog.findViewById(R.id.restartNewGameButton);            dialog.findViewById(R.id.validButton).setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    if (restartThisGameButton.isChecked()) {                        resetSudokuGrid();                    } else if (restartNewGameButton.isChecked()) {                        newGame();                    }                    dialog.dismiss();                }            });            dialog.findViewById(R.id.cancelButton).setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    dialog.dismiss();                }            });            dialog.show();        }    }    private void undoMenuButtonClick() {        if (sudokuGrid.isPaused()) return;        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        if (sudokuGrid.getUndoList().size() > 0) {            final UndoChange currentUndo = sudokuGrid.getUndoList().lastElement();            UndoChange redoChange = currentUndo.doUndo(sudokuGrid, this);            if (redoChange != null) {                addRedo(redoChange);            }            removeUndo(currentUndo);        }    }    private void redoMenuButtonClick() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        if (sudokuGrid.getRedoList().size() > 0) {            final UndoChange currentRedo = sudokuGrid.getRedoList().lastElement();            UndoChange undoChange = currentRedo.doUndo(sudokuGrid, this);            if (undoChange != null) {                addUndo(undoChange);            }            removeRedo(currentRedo);        }    }    private void newGame() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        Intent intent = new Intent(getApplicationContext(),                ConfigureSudokuGridActivity.class);        startActivity(intent);        finish();    }    private void settingsButtonOnClick() {        startActivity(new Intent(this, SettingsActivity.class));    }    private void pauseButtonOnClick() {        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        boolean paused = !sudokuGrid.isPaused();        sudokuGrid.setPaused(paused);        if (paused) {            sudokuGrid.pauseGrid();        } else {            sudokuGrid.resumeGrid();        }        updatePaused();    }    private void updatePaused() {        if (sudokuGrid.isPaused()) {            pause.setImageResource(R.drawable.ic_play);            mainGrid.setVisibility(View.INVISIBLE);        } else {            pause.setImageResource(R.drawable.ic_pause);            mainGrid.setVisibility(View.VISIBLE);        }    }    private void popupCreate() {        LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);        assert inflater != null;        @SuppressLint("InflateParams")        View customView = inflater.inflate(R.layout.layout_popup, null);        popup = new PopupWindow(customView,                CoordinatorLayout.LayoutParams.WRAP_CONTENT,                CoordinatorLayout.LayoutParams.WRAP_CONTENT);        popup.setOutsideTouchable(true);        popup.setFocusable(true);        popup.setBackgroundDrawable(getResources().getDrawable(R.drawable.popup_border));        popup.setOnDismissListener(new PopupWindow.OnDismissListener() {            @Override            public void onDismiss() {                if (numberClick_currentNumber != null)                    numberClick_currentNumber.setSelected(false);                lastButtonPopupClickId = -1;                buttonPopupSelectedNumbers.clear();            }        });        popupButton[0] = popup.getContentView().findViewById(R.id.ButtonNothing);        popupButton[1] = popup.getContentView().findViewById(R.id.Button1);        popupButton[2] = popup.getContentView().findViewById(R.id.Button2);        popupButton[3] = popup.getContentView().findViewById(R.id.Button3);        popupButton[4] = popup.getContentView().findViewById(R.id.Button4);        popupButton[5] = popup.getContentView().findViewById(R.id.Button5);        popupButton[6] = popup.getContentView().findViewById(R.id.Button6);        popupButton[7] = popup.getContentView().findViewById(R.id.Button7);        popupButton[8] = popup.getContentView().findViewById(R.id.Button8);        popupButton[9] = popup.getContentView().findViewById(R.id.Button9);        popupButton[10] = popup.getContentView().findViewById(R.id.ButtonCancel);        popupButton[11] = popup.getContentView().findViewById(R.id.ButtonValid);        for (int i = 0; i < popupButton.length; i++) {            final int finalI = i;            popupButton[i].setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    onButtonPopupClick(finalI);                }            });        }    }    private void onButtonPopupClick(int buttonId) {        if (buttonId == 10) {            popup.dismiss();        } else if (buttonId == 11) {            if (sudokuGrid.getSortNotes())                Collections.sort(buttonPopupSelectedNumbers);            SudokuNumberList newNumber = new SudokuNumberList(buttonPopupSelectedNumbers);            SudokuNumberList previousNumber = sudokuGrid.getUserModify(                    numberClick_currentNumberCoordinate[0],                    numberClick_currentNumberCoordinate[1]            );            if (                    !clickButtonEqual(newNumber, previousNumber) ||                            sudokuGrid.getColorGrid(                                    numberClick_currentNumberCoordinate[0],                                    numberClick_currentNumberCoordinate[1]                            ) != listColorChoose[sudokuGrid.getColorChooseSelected()]) {                remainingNumberChange(previousNumber, newNumber);                addUndo(new UndoChange(                        numberClick_currentNumberCoordinate[0],                        numberClick_currentNumberCoordinate[1],                        sudokuGrid.getUserModify(                                numberClick_currentNumberCoordinate[0],                                numberClick_currentNumberCoordinate[1]                        ),                        sudokuGrid.getColorGrid(                                numberClick_currentNumberCoordinate[0],                                numberClick_currentNumberCoordinate[1]                        )));                clearRedoList();                sudokuGrid.setUserModify(                        numberClick_currentNumberCoordinate[0],                        numberClick_currentNumberCoordinate[1],                        buttonPopupSelectedNumbers                );                sudokuGrid.setColorGrid(                        numberClick_currentNumberCoordinate[0],                        numberClick_currentNumberCoordinate[1],                        listColorChoose[sudokuGrid.getColorChooseSelected()]                );                updateNumberTile(numberClick_currentNumberCoordinate[0],                        numberClick_currentNumberCoordinate[1]);                updateWinAndConflict();            }            popup.dismiss();        } else if (buttonId == 0) {            if (lastButtonPopupClickId == buttonId &&                    System.currentTimeMillis() - lastButtonPopupClickDelay <= DELAY_DOUBLE_CLICK) {                onButtonPopupClick(11); // valid            } else {                lastButtonPopupClickId = buttonId;                lastButtonPopupClickDelay = System.currentTimeMillis();                popupButton[buttonId].setSelect(!popupButton[buttonId].isSelect());                buttonPopupSelectedNumbers.clear();                for (ButtonPopupNumber buttonPopupNumber : popupButton) {                    if (buttonPopupNumber.isSelectable()) {                        buttonPopupNumber.setSelect(false);                    }                }            }        } else if (popupButton[buttonId].isSelectable()) {            if (lastButtonPopupClickId == buttonId &&                    System.currentTimeMillis() - lastButtonPopupClickDelay <= DELAY_DOUBLE_CLICK) {                buttonPopupSelectedNumbers.clear();                buttonPopupSelectedNumbers.add(SudokuNumbersEnum.get(buttonId));                onButtonPopupClick(11); // valid            } else {                lastButtonPopupClickId = buttonId;                lastButtonPopupClickDelay = System.currentTimeMillis();                popupButton[buttonId].setSelect(!popupButton[buttonId].isSelect());                if (popupButton[buttonId].isSelect()) {                    buttonPopupSelectedNumbers.add(SudokuNumbersEnum.get(buttonId));                } else {                    buttonPopupSelectedNumbers.remove(SudokuNumbersEnum.get(buttonId));                }            }        }    }    private void updateWinAndConflict() {        if (showConflict) {            new Handler(getMainLooper()).post(new Runnable() {                @Override                public void run() {                    testWin();                    testConflict(numberClick_currentNumberCoordinate[0],                            numberClick_currentNumberCoordinate[1]);                }            });        } else {            new Handler(getMainLooper()).post(new Runnable() {                @Override                public void run() {                    testWin();                }            });        }    }    private void testWin() {        if (!sudokuGrid.isGameFinish() && sudokuGrid.getNumberTileRemaining() <= 0) {            if (sudokuGrid.verifyGrid()) {                stopGame(true);            }        }    }    private void resetSudokuGrid() {        sudokuGrid.resetGrid();        mainGrid.removeAllViews();        clearRedoList();        clearUndoList();        createGridGraphics();        updatePaused();        if (sudokuGrid.getTimerSettings() == SudokuApplication.TIMER_SHOW)            updateTimeView(false);    }    private void createGridGraphics() {        final ArrayList<int[]> listCheckConflict = new ArrayList<>(); // 0: x, 1: y        int number_size = (widthToResize - 50) / 9;        mainGrid.setColumnCount(3);        mainGrid.setRowCount(3);        for (int gridLayout = 0; gridLayout < 9; gridLayout++) {            listGridLayout[gridLayout] = new GridLayout(this);            listGridLayout[gridLayout].setBackgroundResource(R.drawable.large_border);            listGridLayout[gridLayout].setPadding(2, 2, 2, 2);            listGridLayout[gridLayout].setRowCount(3);            listGridLayout[gridLayout].setColumnCount(3);            mainGrid.addView(listGridLayout[gridLayout]);            for (int i = 0; i < 9; i++) {                final int x = i % 3 + gridLayout % 3 * 3;                final int y = i / 3 + gridLayout / 3 * 3;                listTileViews[x][y] = new TileView(this);                listTileViews[x][y].setBaseSizeFont(number_size * 0.9f);                listTileViews[x][y].setBackgroundColor(sudokuGrid.getColorGrid(x, y));                SudokuNumberList enumList = sudokuGrid.getUserModify(x, y);                if (enumList.getUniqueNumber() == SudokuNumbersEnum.NotModifiable) {                    listTileViews[x][y].setNumber(sudokuGrid.get(x, y));                    listTileViews[x][y].setType(NumberTypeEnum.Number);                } else if (enumList.getUniqueNumber() == SudokuNumbersEnum.Hint) {                    listTileViews[x][y].setNumber(sudokuGrid.get(x, y));                    listTileViews[x][y].setType(NumberTypeEnum.Hint);                } else {                    listTileViews[x][y].setType(NumberTypeEnum.UserInput);                    listTileViews[x][y].setNumber(enumList);                    if (sudokuGrid.getUserModify(x, y).getUniqueNumber() !=                            SudokuNumbersEnum.Blank) {                        int[] toCheck = new int[2];                        toCheck[0] = x;                        toCheck[1] = y;                        listCheckConflict.add(toCheck);                    }                }                listTileViews[x][y].setOnClickListener(new View.OnClickListener() {                    @Override                    public void onClick(View v) {                        onNumberClick((TileView) v, x, y);                    }                });                CoordinatorLayout.LayoutParams params = new                        CoordinatorLayout.LayoutParams(number_size, number_size);                listTileViews[x][y].setLayoutParams(params);                listGridLayout[gridLayout].addView(listTileViews[x][y]);            }        }        if (showConflict && !listCheckConflict.isEmpty())            new Handler(getMainLooper()).post(new Runnable() {                @Override                public void run() {                    for (int[] toCheck : listCheckConflict) {                        testConflict(toCheck[0], toCheck[1]);                    }                }            });        undoImageView.setImageDrawable(sudokuGrid.getUndoList().empty() ?                getResources().getDrawable(R.drawable.ic_action_undo_disable) :                getResources().getDrawable(R.drawable.ic_action_undo));        redoImageView.setImageDrawable(sudokuGrid.getRedoList().empty() ?                getResources().getDrawable(R.drawable.ic_action_redo_disable) :                getResources().getDrawable(R.drawable.ic_action_redo));    }    private void onNumberClick(TileView tileView, int x, int y) {        if (sudokuGrid.isPaused()) return;        if (swapMode) {            if (selectedNumberSwap[0] == x && selectedNumberSwap[1] == y) {                setSwapMode(false);                doColorSwap(sudokuGrid.getColorGrid(x, y),                        listColorChoose[selectedColorToSwap]);            } else if (selectedColorToSwap != -1) { // verify the color is already select                if (numberClick_currentNumber != null)                    numberClick_currentNumber.setSelected(false);                selectedNumberSwap[0] = x;                selectedNumberSwap[1] = y;                numberClick_currentNumber = tileView;                numberClick_currentNumber.setSelected(true);                informationTextView.setText(R.string.swap_color_confirm_click_ask);            }        } else {            if (sudokuGrid.getUserModify(x, y).getUniqueNumber().isModifiable()) {                if (numberClick_currentNumber != null)                    numberClick_currentNumber.setSelected(false);                numberClick_currentNumber = tileView;                numberClick_currentNumber.setSelected(true);                numberClick_currentNumberCoordinate[0] = x;                numberClick_currentNumberCoordinate[1] = y;                if (hintMode) {                    if (hintSelectNumber[0] == x && hintSelectNumber[1] == y) {                        // if is the same number / he click twice on it                        setHintMode(false);                        // give hint                        if (!sudokuGrid.getUserModify(x, y).getUniqueNumber().isModifiable())                            sudokuGrid.removeNumberTileRemaining();                        tileView.setType(NumberTypeEnum.Hint);                        tileView.setNumber(sudokuGrid.get(x, y));                        sudokuGrid.setHint(x, y);                        removeNumberUndoRedo(x, y);                        updateWinAndConflict();                    } else {                        hintSelectNumber[0] = x;                        hintSelectNumber[1] = y;                        informationTextView.setText(R.string.hint_new_click_ask);                    }                } else {                    buttonPopupSelectedNumbers.clear();                    if (sudokuGrid.getUserModify(x, y).getUniqueNumber() != SudokuNumbersEnum.Blank) {                        SudokuNumbersEnum[] list;                        list = sudokuGrid.getUserModify(x, y).getMultipleNumber();                        buttonPopupSelectedNumbers.addAll(Arrays.asList(list));                    }                    for (int i = 0; i < 9; i++) {                        popupButton[i + 1].setSelect(                                buttonPopupSelectedNumbers.contains(SudokuNumbersEnum.get(i + 1))                        );                    }                    popup.showAtLocation(mainGrid, Gravity.CENTER, 0, 0);                }            } else {                if (listColorChoose[sudokuGrid.getColorChooseSelected()] != sudokuGrid.getColorGrid(x, y)) {                    clearRedoList();                    addUndo(new UndoChange(x, y, sudokuGrid.getColorGrid(x, y)));                    tileView.setBackgroundColor(listColorChoose[sudokuGrid.getColorChooseSelected()]);                    sudokuGrid.setColorGrid(x, y,                            listColorChoose[sudokuGrid.getColorChooseSelected()]);                }            }        }    }    public void updateNumberTile(int x, int y) {        if (sudokuGrid.getUserModify(x, y).getUniqueNumber().isModifiable())            listTileViews[x][y].setNumber(sudokuGrid.getUserModify(x, y));        listTileViews[x][y].setBackgroundColor(sudokuGrid.getColorGrid(x, y));    }    public void testConflict(int tileX, int tileY) {        testConflict(tileX, tileY, true);    }    public void testConflict(int tileX, int tileY, boolean updateAlreadyConflict) {        // test columns        ArrayList<Integer[]> listNumbersUpdate = new ArrayList<>(); // int[]: 0: x, 1: y        boolean currentNumberConflict = false;        for (int column = 0; column < 9; column++) {            if (tileY != column) {                if (getNumberModify(tileX, tileY).canBeConflict() &&                        getNumberModify(tileX, tileY) == getNumberModify(tileX, column)) {                    currentNumberConflict = true;                    listTileViews[tileX][column].setConflict(true);                } else if (updateAlreadyConflict &&                        listTileViews[tileX][column].isInConflict()) {                    Integer[] cord = new Integer[2];                    cord[0] = tileX;                    cord[1] = column;                    listNumbersUpdate.add(cord);                }            }        }        // test lines        for (int line = 0; line < 9; line++) {            if (tileX != line) {                if (getNumberModify(tileX, tileY).canBeConflict() &&                        getNumberModify(tileX, tileY) == getNumberModify(line, tileY)) {                    currentNumberConflict = true;                    listTileViews[line][tileY].setConflict(true);                } else if (updateAlreadyConflict &&                        listTileViews[line][tileY].isInConflict()) {                    Integer[] cord = new Integer[2];                    cord[0] = line;                    cord[1] = tileY;                    listNumbersUpdate.add(cord);                }            }        }        // test square        for (int x = tileX - tileX % 3; x < tileX - tileX % 3 + 3; x++) {            for (int y = tileY - tileY % 3; y < tileY - tileY % 3 + 3; y++) {                if (tileX != x || tileY != y) {                    if (getNumberModify(tileX, tileY).canBeConflict() &&                            getNumberModify(tileX, tileY) == getNumberModify(x, y)) {                        currentNumberConflict = true;                        listTileViews[x][y].setConflict(true);                    } else if (updateAlreadyConflict &&                            listTileViews[x][y].isInConflict()) {                        Integer[] cord = new Integer[2];                        cord[0] = x;                        cord[1] = y;                        listNumbersUpdate.add(cord);                    }                }            }        }        listTileViews[tileX][tileY].setConflict(currentNumberConflict);        for (Integer[] cord : listNumbersUpdate) {            testConflict(cord[0], cord[1], false);        }    }    private void stopGame(boolean win) {        stopGame(win, false);    }    private void stopGame(boolean win, boolean gameAlreadyFinish) {        // Log.i("SudokuActivity", "Auto save: stopped"); // LOG_DISABLED        if (!gameAlreadyFinish) {            sudokuGrid.stopGrid();            if (sudokuGrid.isPaused()) {                sudokuGrid.setPaused(false);                updatePaused();            }            timer.cancel();        }        if (sudokuGrid.getTimerSettings() <= SudokuApplication.TIMER_SHOW_END) {            updateTimeView(true);        }        autoSaveHandler.removeCallbacks(autoSaveRunnable);        if (hintMode)            setHintMode(false);        if (swapMode)            setSwapMode(false);        disableClickListeners();        LinearLayout buttonsChooseColorBar = findViewById(R.id.buttonsChooseColor);        LinearLayout buttonsEndGameBar = findViewById(R.id.buttonsEndGameBar);        findViewById(R.id.buttonActionAbort).setVisibility(View.GONE);        findViewById(R.id.buttonActionHint).setVisibility(View.GONE);        findViewById(R.id.buttonActionUndo).setVisibility(View.GONE);        findViewById(R.id.buttonActionRedo).setVisibility(View.GONE);        findViewById(R.id.buttonActionSwapColor).setVisibility(View.GONE);        findViewById(R.id.buttonActionPause).setVisibility(View.GONE);        findViewById(R.id.buttonActionRestart).setVisibility(View.GONE);        endGameTextView.setVisibility(View.VISIBLE);        if (win && testUserDoGrid()) {            // win            sudokuGrid.setGameWin(true);            endGameTextView.setText(R.string.game_result_win);            endGameTextView.setTextColor(getResources().getColor(R.color.text_win));            for (int x = 0; x < 9; x++) {                for (int y = 0; y < 9; y++) {                    if (sudokuGrid.getUserModify(x, y).getUniqueNumber().isModifiable()) {                        listTileViews[x][y].setType(NumberTypeEnum.Win);                    }                }            }        } else {            // lose            sudokuGrid.setGameWin(false);            endGameTextView.setText(R.string.game_result_abort);            endGameTextView.setTextColor(getResources().getColor(R.color.text_lose));            for (int x = 0; x < 9; x++) {                for (int y = 0; y < 9; y++) {                    listTileViews[x][y].setConflict(false); // force to remove conflict color                    if (sudokuGrid.getUserModify(x, y).getUniqueNumber().isModifiable()) {                        if (sudokuGrid.getUserModify(x, y).getUniqueNumber() ==                                sudokuGrid.get(x, y)) {                            listTileViews[x][y].setType(NumberTypeEnum.Win);                        } else {                            listTileViews[x][y].setType(NumberTypeEnum.Lose);                            listTileViews[x][y].setNumber(sudokuGrid.get(x, y));                        }                    }                }            }        }        endGameTextView.startAnimation(AnimationUtils.loadAnimation(this,                R.anim.end_text_animation));        if (!gameAlreadyFinish) {            colorChooseButtonList[sudokuGrid.getColorChooseSelected()].animate().setStartDelay(700)                    .setDuration(300).rotation(0);            buttonsChooseColorBar.startAnimation(AnimationUtils.loadAnimation(this,                    R.anim.end_color_buttons_animation));            buttonsEndGameBar.startAnimation(AnimationUtils.loadAnimation(this,                    R.anim.end_buttons_animation));        } else {            buttonsChooseColorBar.setVisibility(View.INVISIBLE);        }        buttonsEndGameBar.setVisibility(View.VISIBLE);        new Handler(getMainLooper()).post(new Runnable() {            @Override            public void run() {                sudokuGrid.setStatistics(getStatistics()); // update statistics                ((SudokuApplication) getApplicationContext()).saveStatistics();                ((SudokuApplication) getApplicationContext()).saveGrid();            }        });    }    private boolean testUserDoGrid() {        // verify if the user don't use only hint        for (int x = 0; x < 9; x++) {            for (int y = 0; y < 9; y++) {                if (!sudokuGrid.getUserModify(x, y).getUniqueNumber().isModifiable()) { // if the user do that                    return true;                }            }        }        return false;    }    private void disableClickListeners() {        for (int x = 0; x < 9; x++) {            for (int y = 0; y < 9; y++) {                listTileViews[x][y].setOnClickListener(null);                listTileViews[x][y].setBackgroundColor(Color.WHITE);            }        }    }    private void setHintMode(boolean hintMode) {        this.hintMode = hintMode;        if (swapMode)            setSwapMode(false);        if (hintMode) {            timeTextView.setText("");            informationTextView.setText(R.string.hint_mode_text);            informationTextView.startAnimation(AnimationUtils.loadAnimation(this,                    R.anim.information_text_animation));            hintSelectNumber[0] = -1;            hintSelectNumber[1] = -1;        } else {            if (sudokuGrid.getTimerSettings() == SudokuApplication.TIMER_SHOW)                updateTimeView(false);            informationTextView.setText("");            if (numberClick_currentNumber != null)                numberClick_currentNumber.setSelected(false);        }    }    private void setSwapMode(boolean swapMode) {        if (hintMode)            setHintMode(false);        if (swapMode) {            disabledColorButton();            timeTextView.setText("");            informationTextView.setText(R.string.swap_color_choose_color);            informationTextView.startAnimation(AnimationUtils.loadAnimation(this,                    R.anim.information_text_animation));            selectedNumberSwap[0] = -1;            selectedNumberSwap[1] = -1;            selectedColorToSwap = -1;        } else {            enabledColorButton();            informationTextView.setText("");            if (numberClick_currentNumber != null)                numberClick_currentNumber.setSelected(false);        }        this.swapMode = swapMode;        if (sudokuGrid.getTimerSettings() == SudokuApplication.TIMER_SHOW)            updateTimeView(false);    }    private void doColorSwap(int firstColor, int secondColor) {        ArrayList<int[]> listColorChange = new ArrayList<>();        for (int x = 0; x < 9; x++) {            for (int y = 0; y < 9; y++) {                if (sudokuGrid.getColorGrid(x, y) == firstColor) {                    int[] numberModify = new int[]{x, y};                    listColorChange.add(numberModify);                    sudokuGrid.setColorGrid(x, y, secondColor);                    updateNumberTile(x, y);                }            }        }        clearRedoList();        addUndo(new UndoChange(listColorChange, firstColor, secondColor));    }    private void addUndo(UndoChange change) {        sudokuGrid.getUndoList().add(change);        if (sudokuGrid.getUndoList().size() > MAX_UNDO) {            sudokuGrid.getUndoList().remove(0);        } else if (sudokuGrid.getUndoList().size() == 1)            undoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_undo));    }    private void removeUndo(UndoChange undoChange) {        sudokuGrid.getUndoList().remove(undoChange);        if (sudokuGrid.getUndoList().empty())            undoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_undo_disable));    }    private void clearUndoList() {        if (!sudokuGrid.getUndoList().empty()) {            sudokuGrid.getUndoList().clear();            undoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_undo_disable));        }    }    private void removeNumberUndoRedo(int x, int y) {        ArrayList<UndoChange> toRemove = new ArrayList<>();        for (UndoChange undoChange : sudokuGrid.getUndoList()) {            if (undoChange.getType() == UndoEnum.Number) {                if (undoChange.getX() == x && undoChange.getY() == y) {                    toRemove.add(undoChange);                }            }        }        for (UndoChange remove : toRemove) {            removeUndo(remove);        }        toRemove.clear();        for (UndoChange undoChange : sudokuGrid.getRedoList()) {            if (undoChange.getType() == UndoEnum.Number) {                if (undoChange.getX() == x && undoChange.getY() == y) {                    toRemove.add(undoChange);                }            }        }        for (UndoChange remove : toRemove) {            removeRedo(remove);        }    }    private void addRedo(UndoChange change) {        sudokuGrid.getRedoList().add(change);        if (sudokuGrid.getRedoList().size() > MAX_UNDO) {            sudokuGrid.getRedoList().remove(0);        } else if (sudokuGrid.getRedoList().size() == 1)            redoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_redo));    }    private void removeRedo(UndoChange undoChange) {        sudokuGrid.getRedoList().remove(undoChange);        if (sudokuGrid.getRedoList().empty())            redoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_redo_disable));    }    private void clearRedoList() {        if (!sudokuGrid.getRedoList().empty()) {            sudokuGrid.getRedoList().clear();            redoImageView.setImageDrawable(getResources().getDrawable(                    R.drawable.ic_action_redo_disable));        }    }    private void createChooseColorButton() {        LinearLayout listButtons = findViewById(R.id.buttonsChooseColor);        for (int index = 0; index < listColorChoose.length; index++) {            Button button = (Button) getLayoutInflater().inflate(R.layout.button_choose_color_layout,                    listButtons, false);            final int buttonId = index;            button.setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View view) {                    chooseColorButtonOnClick(buttonId);                }            });            button.setBackgroundColor(listColorChooseButtonColor[index]);            colorChooseButtonList[index] = button;            listButtons.addView(button);        }        colorChooseButtonList[sudokuGrid.getColorChooseSelected()].setRotation(45);    }    private void chooseColorButtonOnClick(int id) {        if (swapMode) {            if (id != selectedColorToSwap) {                if (selectedColorToSwap != -1)                    colorChooseButtonList[selectedColorToSwap]                            .animate()                            .rotation(0)                            .setDuration(300);                selectedColorToSwap = id;                colorChooseButtonList[selectedColorToSwap]                        .animate()                        .rotation(45)                        .setDuration(300);                informationTextView.setText(R.string.swap_color_choose_number);            }        } else {            if (id != sudokuGrid.getColorChooseSelected()) {                colorChooseButtonList[sudokuGrid.getColorChooseSelected()]                        .animate()                        .rotation(0)                        .setDuration(300);                sudokuGrid.setColorChooseSelected(id);                colorChooseButtonList[sudokuGrid.getColorChooseSelected()]                        .animate()                        .rotation(45)                        .setDuration(300);            }        }    }    private void disabledColorButton() {        if (swapMode) {            colorChooseButtonList[selectedColorToSwap]                    .animate()                    .rotation(0)                    .setDuration(300);        } else {            colorChooseButtonList[sudokuGrid.getColorChooseSelected()]                    .animate()                    .rotation(0)                    .setDuration(300);        }    }    private void enabledColorButton() {        if (swapMode && selectedColorToSwap != -1) {            colorChooseButtonList[selectedColorToSwap]                    .animate()                    .rotation(0)                    .setDuration(300);        }        colorChooseButtonList[sudokuGrid.getColorChooseSelected()]                .animate()                .rotation(45)                .setDuration(300);    }    private SudokuGrid getSudokuGrid() {        return ((SudokuApplication) getApplicationContext()).getCurrentSudokuGrid();    }    private SudokuStatistics getStatistics() {        return ((SudokuApplication) getApplicationContext()).getSudokuGlobalStatistics();    }    private String getGridId() {        NumberFormat numberFormat = NumberFormat.getInstance(getResources().getConfiguration()                .locale);        numberFormat.setGroupingUsed(true);        return String.valueOf(sudokuGrid.getDifficulty()) + '-' +                numberFormat.format(sudokuGrid.getSeed());    }    private SudokuNumbersEnum getNumberModify(int x, int y) {        if (sudokuGrid.getUserModify(x, y).getUniqueNumber().isModifiable()) {            return sudokuGrid.getUserModify(x, y).getUniqueNumber();        } else {            return sudokuGrid.get(x, y);        }    }    public void remainingNumberChange(SudokuNumberList previousNumber, SudokuNumberList newNumber) {        if (previousNumber.getUniqueNumber().isNumber() != newNumber.getUniqueNumber().isNumber()) {            if (newNumber.getUniqueNumber().isNumber()) {                sudokuGrid.removeNumberTileRemaining();            } else {                sudokuGrid.addNumberTileRemaining();            }        }    }    private boolean clickButtonEqual(SudokuNumberList n1, SudokuNumberList n2) {        SudokuNumbersEnum[] n1List = n1.getMultipleNumber();        SudokuNumbersEnum[] n2List = n2.getMultipleNumber();        if (n1List.length == n2List.length) {            for (int i = 0; i < n1List.length; i++) {                if (n1List[i] != n2List[i]) {                    return false;                }            }            return true;        } else {            return false;        }    }}